# Comparing `tmp/sleap_roots-0.0.8-py3-none-any.whl.zip` & `tmp/sleap_roots-0.0.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,20 +1,20 @@
-Zip file size: 42893 bytes, number of entries: 18
--rw-r--r--  2.0 unx      713 b- defN 24-Apr-12 01:27 sleap_roots/__init__.py
--rw-r--r--  2.0 unx     4213 b- defN 24-Apr-12 01:27 sleap_roots/angle.py
--rw-r--r--  2.0 unx    16062 b- defN 24-Apr-12 01:27 sleap_roots/bases.py
--rw-r--r--  2.0 unx    22558 b- defN 24-Apr-12 01:27 sleap_roots/convhull.py
--rw-r--r--  2.0 unx     3436 b- defN 24-Apr-12 01:27 sleap_roots/ellipse.py
--rw-r--r--  2.0 unx     6175 b- defN 24-Apr-12 01:27 sleap_roots/lengths.py
--rw-r--r--  2.0 unx     6711 b- defN 24-Apr-12 01:27 sleap_roots/networklength.py
--rw-r--r--  2.0 unx    23238 b- defN 24-Apr-12 01:27 sleap_roots/points.py
--rw-r--r--  2.0 unx     3217 b- defN 24-Apr-12 01:27 sleap_roots/scanline.py
--rw-r--r--  2.0 unx    19614 b- defN 24-Apr-12 01:27 sleap_roots/series.py
--rw-r--r--  2.0 unx     2165 b- defN 24-Apr-12 01:27 sleap_roots/summary.py
--rw-r--r--  2.0 unx     2504 b- defN 24-Apr-12 01:27 sleap_roots/tips.py
--rw-r--r--  2.0 unx    87023 b- defN 24-Apr-12 01:27 sleap_roots/trait_pipelines.py
--rw-r--r--  2.0 unx     1518 b- defN 24-Apr-12 01:27 sleap_roots-0.0.8.dist-info/LICENSE
--rw-r--r--  2.0 unx     7029 b- defN 24-Apr-12 01:27 sleap_roots-0.0.8.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-12 01:27 sleap_roots-0.0.8.dist-info/WHEEL
--rw-r--r--  2.0 unx       12 b- defN 24-Apr-12 01:27 sleap_roots-0.0.8.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1445 b- defN 24-Apr-12 01:27 sleap_roots-0.0.8.dist-info/RECORD
-18 files, 207725 bytes uncompressed, 40557 bytes compressed:  80.5%
+Zip file size: 43644 bytes, number of entries: 18
+-rw-r--r--  2.0 unx      713 b- defN 24-Apr-23 18:33 sleap_roots/__init__.py
+-rw-r--r--  2.0 unx     4213 b- defN 24-Apr-23 18:33 sleap_roots/angle.py
+-rw-r--r--  2.0 unx    16062 b- defN 24-Apr-23 18:33 sleap_roots/bases.py
+-rw-r--r--  2.0 unx    22852 b- defN 24-Apr-23 18:33 sleap_roots/convhull.py
+-rw-r--r--  2.0 unx     3436 b- defN 24-Apr-23 18:33 sleap_roots/ellipse.py
+-rw-r--r--  2.0 unx     6175 b- defN 24-Apr-23 18:33 sleap_roots/lengths.py
+-rw-r--r--  2.0 unx     6711 b- defN 24-Apr-23 18:33 sleap_roots/networklength.py
+-rw-r--r--  2.0 unx    25061 b- defN 24-Apr-23 18:33 sleap_roots/points.py
+-rw-r--r--  2.0 unx     3217 b- defN 24-Apr-23 18:33 sleap_roots/scanline.py
+-rw-r--r--  2.0 unx    20331 b- defN 24-Apr-23 18:33 sleap_roots/series.py
+-rw-r--r--  2.0 unx     2165 b- defN 24-Apr-23 18:33 sleap_roots/summary.py
+-rw-r--r--  2.0 unx     2504 b- defN 24-Apr-23 18:33 sleap_roots/tips.py
+-rw-r--r--  2.0 unx    87334 b- defN 24-Apr-23 18:33 sleap_roots/trait_pipelines.py
+-rw-r--r--  2.0 unx     1518 b- defN 24-Apr-23 18:33 sleap_roots-0.0.9.dist-info/LICENSE
+-rw-r--r--  2.0 unx     7029 b- defN 24-Apr-23 18:33 sleap_roots-0.0.9.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-23 18:33 sleap_roots-0.0.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx       12 b- defN 24-Apr-23 18:33 sleap_roots-0.0.9.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1445 b- defN 24-Apr-23 18:33 sleap_roots-0.0.9.dist-info/RECORD
+18 files, 210870 bytes uncompressed, 41308 bytes compressed:  80.4%
```

## zipnote {}

```diff
@@ -33,23 +33,23 @@
 
 Filename: sleap_roots/tips.py
 Comment: 
 
 Filename: sleap_roots/trait_pipelines.py
 Comment: 
 
-Filename: sleap_roots-0.0.8.dist-info/LICENSE
+Filename: sleap_roots-0.0.9.dist-info/LICENSE
 Comment: 
 
-Filename: sleap_roots-0.0.8.dist-info/METADATA
+Filename: sleap_roots-0.0.9.dist-info/METADATA
 Comment: 
 
-Filename: sleap_roots-0.0.8.dist-info/WHEEL
+Filename: sleap_roots-0.0.9.dist-info/WHEEL
 Comment: 
 
-Filename: sleap_roots-0.0.8.dist-info/top_level.txt
+Filename: sleap_roots-0.0.9.dist-info/top_level.txt
 Comment: 
 
-Filename: sleap_roots-0.0.8.dist-info/RECORD
+Filename: sleap_roots-0.0.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## sleap_roots/__init__.py

```diff
@@ -19,8 +19,8 @@
     OlderMonocotPipeline,
     MultipleDicotPipeline,
 )
 from sleap_roots.series import Series, find_all_series
 
 # Define package version.
 # This is read dynamically by setuptools in pyproject.toml to determine the release version.
-__version__ = "0.0.8"
+__version__ = "0.0.9"
```

## sleap_roots/convhull.py

```diff
@@ -1,14 +1,17 @@
 """Convex hull fitting and derived trait calculation."""
 
 import numpy as np
 from scipy.spatial import ConvexHull
 from scipy.spatial.distance import pdist
 from typing import Tuple, Optional, Union
-from sleap_roots.points import get_line_equation_from_points
+from sleap_roots.points import (
+    extract_points_from_geometry,
+    get_line_equation_from_points,
+)
 from shapely import box, LineString, normalize, Polygon
 
 
 def get_convhull(pts: np.ndarray) -> Optional[ConvexHull]:
     """Compute the convex hull for the points per frame.
 
     Args:
@@ -378,21 +381,17 @@
     hull_perimeter = LineString(
         hull.points[hull.vertices].tolist() + [hull.points[hull.vertices[0]].tolist()]
     )
 
     # Find the intersection between the hull perimeter and the extended line
     intersection = extended_line.intersection(hull_perimeter)
 
-    # Add intersection points to both lists
+    # Compute the intersection points and add to lists
     if not intersection.is_empty:
-        intersect_points = (
-            np.array([[point.x, point.y] for point in intersection.geoms])
-            if intersection.geom_type == "MultiPoint"
-            else np.array([[intersection.x, intersection.y]])
-        )
+        intersect_points = extract_points_from_geometry(intersection)
         above_line.extend(intersect_points)
         below_line.extend(intersect_points)
 
     # Calculate areas using get_chull_area
     area_above_line = get_chull_area(np.array(above_line)) if above_line else 0.0
     area_below_line = get_chull_area(np.array(below_line)) if below_line else 0.0
 
@@ -448,23 +447,29 @@
         A tuple containing vectors from the top left point to the left intersection point, and from
         the top right point to the right intersection point with the convex hull. Returns two vectors
         of NaNs if the vectors can't be calculated. Vectors are of shape (1, 2).
 
     Raises:
         ValueError: If pts does not have the expected shape.
     """
+    if r0_pts.ndim == 1 or rn_pts.ndim == 1 or pts.ndim == 2:
+        print(
+            "Not enough instances or incorrect format to compute convex hull intersections."
+        )
+        return (np.array([[np.nan, np.nan]]), np.array([[np.nan, np.nan]]))
+
     # Check for valid pts input
     if not isinstance(pts, np.ndarray) or pts.ndim != 3 or pts.shape[-1] != 2:
         raise ValueError("pts must be a numpy array of shape (instances, nodes, 2).")
     # Ensure rn_pts is a numpy array of shape (instances, 2)
     if not isinstance(rn_pts, np.ndarray) or rn_pts.ndim != 2 or rn_pts.shape[-1] != 2:
         raise ValueError("rn_pts must be a numpy array of shape (instances, 2).")
     # Ensure r0_pts is a numpy array of shape (instances, 2)
     if not isinstance(r0_pts, np.ndarray) or r0_pts.ndim != 2 or r0_pts.shape[-1] != 2:
-        raise ValueError("r0_pts must be a numpy array of shape (instances, 2).")
+        raise ValueError(f"r0_pts must be a numpy array of shape (instances, 2).")
 
     # Flatten pts to 2D array and remove NaN values
     flattened_pts = pts.reshape(-1, 2)
     valid_pts = flattened_pts[~np.isnan(flattened_pts).any(axis=1)]
     # Get unique points
     unique_pts = np.unique(valid_pts, axis=0)
 
@@ -477,14 +482,17 @@
     rn_pts_valid = rn_pts[~np.isnan(rn_pts).any(axis=1)]
     # Need at least two points to define a line
     if len(rn_pts_valid) < 2:
         return (np.array([[np.nan, np.nan]]), np.array([[np.nan, np.nan]]))
 
     # Ensuring r0_pts does not contain NaN values
     r0_pts_valid = r0_pts[~np.isnan(r0_pts).any(axis=1)]
+    # Expect two vectors in the end
+    if len(r0_pts_valid) < 2:
+        return (np.array([[np.nan, np.nan]]), np.array([[np.nan, np.nan]]))
 
     # Get the vertices of the convex hull
     hull_vertices = hull.points[hull.vertices]
 
     # Find the leftmost and rightmost r0 point
     leftmost_r0 = r0_pts_valid[np.argmin(r0_pts_valid[:, 0])]
     rightmost_r0 = r0_pts_valid[np.argmax(r0_pts_valid[:, 0])]
```

## sleap_roots/points.py

```diff
@@ -1,17 +1,55 @@
 """Get traits related to the points."""
 
 import numpy as np
 from matplotlib import pyplot as plt
 from matplotlib.lines import Line2D
-from shapely.geometry import LineString
+from shapely.geometry import Point, MultiPoint, LineString, GeometryCollection
 from shapely.ops import nearest_points
 from typing import List, Optional, Tuple
 
 
+def extract_points_from_geometry(geometry):
+    """Extracts coordinates as a list of numpy arrays from any given Shapely geometry object.
+
+    This function supports Point, MultiPoint, LineString, and GeometryCollection types.
+    It recursively extracts coordinates from complex geometries and aggregates them into a single list.
+    For unsupported geometry types, it returns an empty list.
+
+    Args:
+        geometry (shapely.geometry.base.BaseGeometry): A Shapely geometry object from which to extract points.
+
+    Returns:
+        List[np.ndarray]: A list of numpy arrays, where each array represents the coordinates of a point.
+        The list will be empty if the geometry type is unsupported or contains no coordinates.
+
+    Example:
+    >>> from shapely.geometry import Point, MultiPoint, LineString, GeometryCollection
+    >>> point = Point(1, 2)
+    >>> multipoint = MultiPoint([(1, 2), (3, 4)])
+    >>> linestring = LineString([(0, 0), (1, 1), (2, 2)])
+    >>> geom_col = GeometryCollection([point, multipoint, linestring])
+    >>> extract_points_from_geometry(geom_col)
+    [array([1, 2]), array([1, 2]), array([3, 4]), array([0, 0]), array([1, 1]), array([2, 2])]
+    """
+    if isinstance(geometry, Point):
+        return [np.array([geometry.x, geometry.y])]
+    elif isinstance(geometry, MultiPoint):
+        return [np.array([point.x, point.y]) for point in geometry.geoms]
+    elif isinstance(geometry, LineString):
+        return [np.array([x, y]) for x, y in zip(*geometry.xy)]
+    elif isinstance(geometry, GeometryCollection):
+        points = []
+        for geom in geometry.geoms:
+            points.extend(extract_points_from_geometry(geom))
+        return points
+    else:
+        raise TypeError(f"Unsupported geometry type: {type(geometry).__name__}")
+
+
 def get_count(pts: np.ndarray):
     """Get number of roots.
 
     Args:
         pts: Root landmarks as array of shape `(instances, nodes, 2)`.
 
     Return:
```

## sleap_roots/series.py

```diff
@@ -35,14 +35,15 @@
         get_lateral_points: Get lateral root points.
         get_crown_points: Get crown root points.
 
     Properties:
         series_name: Name of the series derived from the HDF5 filename.
         expected_count: Fetch the expected plant count for this series from the CSV.
         group: Group name for the series from the CSV.
+        qc_fail: Flag to indicate if the series failed QC from the CSV.
     """
 
     h5_path: Optional[str] = None
     primary_labels: Optional[sio.Labels] = None
     lateral_labels: Optional[sio.Labels] = None
     crown_labels: Optional[sio.Labels] = None
     video: Optional[sio.Video] = None
@@ -157,14 +158,28 @@
         try:
             # Match the series_name (or plant_qr_code in the CSV) to fetch the group
             return df[df["plant_qr_code"] == self.series_name]["genotype"].iloc[0]
         except IndexError:
             print(f"No group found for series {self.series_name} in CSV.")
             return np.nan
 
+    @property
+    def qc_fail(self) -> Union[int, float]:
+        """Flag to indicate if the series failed QC from the CSV."""
+        if not self.csv_path or not Path(self.csv_path).exists():
+            print("CSV path is not set or the file does not exist.")
+            return np.nan
+        df = pd.read_csv(self.csv_path)
+        try:
+            # Match the series_name (or plant_qr_code in the CSV) to fetch the QC flag
+            return df[df["plant_qr_code"] == self.series_name]["qc_cylinder"].iloc[0]
+        except IndexError:
+            print(f"No QC flag found for series {self.series_name} in CSV.")
+            return np.nan
+
     def __len__(self) -> int:
         """Length of the series (number of images)."""
         return len(self.video)
 
     def __getitem__(self, idx: int) -> Dict[str, Optional[sio.LabeledFrame]]:
         """Return labeled frames for primary and/or lateral and/or crown predictions."""
         return self.get_frame(idx)
```

## sleap_roots/trait_pipelines.py

```diff
@@ -397,20 +397,21 @@
             series: The Series object containing the primary and lateral root points.
             write_json: Whether to write the aggregated traits to a JSON file. Default is False.
             json_suffix: The suffix to append to the JSON file name. Default is ".all_frames_traits.json".
             write_csv: Whether to write the summary statistics to a CSV file. Default is False.
             csv_suffix: The suffix to append to the CSV file name. Default is ".all_frames_summary.csv".
 
         Returns:
-            A dictionary containing the series name, group, aggregated traits, and summary statistics.
+            A dictionary containing the series name, group, qc_fail, aggregated traits, and summary statistics.
         """
         # Initialize the return structure with the series name and group
         result = {
             "series": str(series.series_name),
             "group": str(series.group),
+            "qc_fail": series.qc_fail,
             "traits": {},
             "summary_stats": {},
         }
 
         # Check if the series has frames to process
         if len(series) == 0:
             print(f"Series '{series.series_name}' contains no frames to process.")
@@ -524,14 +525,19 @@
             isinstance(series, Series) for series in series_list
         ):
             raise ValueError("series_list must be a list of Series objects.")
 
         # Group series by their group property
         series_groups = {}
         for series in series_list:
+            # Exclude series with qc_fail flag set to 1
+            if int(series.qc_fail) == 1:
+                print(f"Skipping series '{series.series_name}' due to qc_fail flag.")
+                continue
+            # Get the group name from the series object
             group_name = str(series.group)
             if group_name not in series_groups:
                 series_groups[group_name] = {"names": [], "series": []}
             # Store series names and objects in the dictionary
             series_groups[group_name]["names"].append(str(series.series_name))
             series_groups[group_name]["series"].append(series)  # Store Series objects
 
@@ -729,15 +735,15 @@
             output_dir: The directory to write the JSON and CSV files to. Default is "grouped_traits".
             write_json: If `True`, write each set of group traits to a JSON file.
             write_csv: If `True`, write the computed traits to a CSV file.
             csv_path: Path to write the CSV file to.
 
         Returns:
             A pandas DataFrame of computed traits summarized over all frames of each
-            series. The resulting dataframe will have a row for each series and a column
+            group. The resulting dataframe will have a row for each series and a column
             for each series-level summarized trait.
 
             Summarized traits are prefixed with the trait name and an underscore,
             followed by the summary statistic.
         """
         # Check if the input list is empty
         if not all_series:
```

## Comparing `sleap_roots-0.0.8.dist-info/LICENSE` & `sleap_roots-0.0.9.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `sleap_roots-0.0.8.dist-info/METADATA` & `sleap_roots-0.0.9.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: sleap-roots
-Version: 0.0.8
+Version: 0.0.9
 Summary: Analysis tools for SLEAP-based plant root phenotyping.
 Author-email: Elizabeth Berrigan <eberrigan@salk.edu>, Lin Wang <linwang@salk.edu>, Talmo Pereira <talmo@salk.edu>
 License: BSD-3-Clause
 Project-URL: Homepage, https://github.com/talmolab/sleap-roots
 Project-URL: Repository, https://github.com/talmolab/sleap-roots
 Keywords: sleap,plants,roots,phenotyping
 Classifier: Programming Language :: Python :: 3.7
```

## Comparing `sleap_roots-0.0.8.dist-info/RECORD` & `sleap_roots-0.0.9.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,18 +1,18 @@
-sleap_roots/__init__.py,sha256=myG211MqQKt7o-ddV6FABVtTBBev8V0B8Wc8HeLPWY8,713
+sleap_roots/__init__.py,sha256=qlTME5wIK5nBAAt5oZ_6oixyOJU0UKlU-u6Xpcw7RrE,713
 sleap_roots/angle.py,sha256=OgXp1gOxSKsDmSADT1zyTx3v0xYSnAHjZZJVtoAO0sQ,4213
 sleap_roots/bases.py,sha256=BlInBzUI_QA9kn4RsZqf1ypIH5lBdmr-mdmnKI8-wpI,16062
-sleap_roots/convhull.py,sha256=pIdyDgZOFrhCvVuoA8zxpzAJlh8fGn4aaPqpsoZKMR0,22558
+sleap_roots/convhull.py,sha256=uFCA5Ui8aBpgpjbBN7FwXePMnHQVeVbaHdIbXnpcZP8,22852
 sleap_roots/ellipse.py,sha256=UwIVSKzO8C6-yC3t9OY1ibQoBR4iq2LdczqXvvo5lKI,3436
 sleap_roots/lengths.py,sha256=LIpl7ymJuCfCK99NlC8kghe9LoLyzfbzKRoSoW6Bees,6175
 sleap_roots/networklength.py,sha256=cOyChfpmS8d5S1oT9OA2PsLWkJoHDsHfFjGoC_XNl4c,6711
-sleap_roots/points.py,sha256=JSHvIwhX1k4Q-AJ2K6JCMiT3sRnwyPdYGt9g2NbO4CA,23238
+sleap_roots/points.py,sha256=S7Ua8OC8-6LX00rd-6z9Upb_O8P-kSWl89mm1xUhaf0,25061
 sleap_roots/scanline.py,sha256=Le2-s6wsct9-gMalw5fc2bDyOcPXj2DyF9v2_4gt3O4,3217
-sleap_roots/series.py,sha256=LdjPsh68_lAIU2rLgHfGw8X___-LmQKWn36WG2OmqME,19614
+sleap_roots/series.py,sha256=Qh2T93bbfbdyuF4otX1STKOs8X1HdJOVP38vzukf2m4,20331
 sleap_roots/summary.py,sha256=aCykxYljb3viFUGrzrO3E-NuLqC4tdatYMeiNAGu00Q,2165
 sleap_roots/tips.py,sha256=RixNUJPDS1lKExAeo70lQcAAffmeVXEgROZBPq1qIAo,2504
-sleap_roots/trait_pipelines.py,sha256=e_MBcF1EtXI5c40wZBHFOcxTbhPmMzeyJ4SJiyQTacQ,87023
-sleap_roots-0.0.8.dist-info/LICENSE,sha256=_Wx8fXeq5NzY4rwYOxSpnCYgD6ILGby6nk62nc7KrIM,1518
-sleap_roots-0.0.8.dist-info/METADATA,sha256=qXCa3q3OCCW0_GzIlHnZ8h1BeSsRHTYgRnFhdMYNJw4,7029
-sleap_roots-0.0.8.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-sleap_roots-0.0.8.dist-info/top_level.txt,sha256=jtAGw39M7JxxF_vLiOlLvUrZB2jpg_qNryhCa0n-WV0,12
-sleap_roots-0.0.8.dist-info/RECORD,,
+sleap_roots/trait_pipelines.py,sha256=uF-R7JHg3XO9RxgRDkUi98nfGoU7mdGKalVscSVETiE,87334
+sleap_roots-0.0.9.dist-info/LICENSE,sha256=_Wx8fXeq5NzY4rwYOxSpnCYgD6ILGby6nk62nc7KrIM,1518
+sleap_roots-0.0.9.dist-info/METADATA,sha256=j6kv2KL431MfT6hPYfS4H0vL0Bq09LiJVBgfJ_3o-A8,7029
+sleap_roots-0.0.9.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+sleap_roots-0.0.9.dist-info/top_level.txt,sha256=jtAGw39M7JxxF_vLiOlLvUrZB2jpg_qNryhCa0n-WV0,12
+sleap_roots-0.0.9.dist-info/RECORD,,
```

