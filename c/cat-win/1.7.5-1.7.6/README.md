# Comparing `tmp/cat_win-1.7.5-py3-none-any.whl.zip` & `tmp/cat_win-1.7.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,93 +1,104 @@
-Zip file size: 108431 bytes, number of entries: 91
--rw-r--r--  2.0 fat      305 b- defN 24-Apr-06 23:11 cat_win/__init__.py
--rw-r--r--  2.0 fat      483 b- defN 24-Apr-06 22:15 cat_win/__main__.py
--rw-r--r--  2.0 fat    52923 b- defN 24-Apr-06 22:15 cat_win/cat.py
--rw-r--r--  2.0 fat      391 b- defN 24-Apr-06 22:15 cat_win/shell.py
--rw-r--r--  2.0 fat        0 b- defN 24-Apr-06 22:15 cat_win/const/__init__.py
--rw-r--r--  2.0 fat     8829 b- defN 24-Apr-06 22:15 cat_win/const/argconstants.py
--rw-r--r--  2.0 fat     2661 b- defN 24-Apr-06 22:15 cat_win/const/colorconstants.py
--rw-r--r--  2.0 fat      711 b- defN 24-Apr-06 22:15 cat_win/const/defaultconstants.py
--rw-r--r--  2.0 fat        0 b- defN 24-Apr-06 22:15 cat_win/persistence/__init__.py
--rw-r--r--  2.0 fat    10585 b- defN 24-Apr-06 22:15 cat_win/persistence/cconfig.py
--rw-r--r--  2.0 fat     9773 b- defN 24-Apr-06 22:15 cat_win/persistence/config.py
--rw-r--r--  2.0 fat        0 b- defN 24-Apr-06 22:15 cat_win/tests/__init__.py
--rw-r--r--  2.0 fat     4492 b- defN 24-Apr-06 22:15 cat_win/tests/test_ansi.py
--rw-r--r--  2.0 fat     1187 b- defN 24-Apr-06 22:15 cat_win/tests/test_argconstants.py
--rw-r--r--  2.0 fat    12486 b- defN 24-Apr-06 22:15 cat_win/tests/test_argparser.py
--rw-r--r--  2.0 fat     8978 b- defN 24-Apr-06 22:15 cat_win/tests/test_cat.py
--rw-r--r--  2.0 fat     1139 b- defN 24-Apr-06 22:15 cat_win/tests/test_cbase64.py
--rw-r--r--  2.0 fat     1564 b- defN 24-Apr-06 22:15 cat_win/tests/test_cconfig.py
--rw-r--r--  2.0 fat     1763 b- defN 24-Apr-06 22:15 cat_win/tests/test_checksum.py
--rw-r--r--  2.0 fat     3293 b- defN 24-Apr-06 22:15 cat_win/tests/test_config.py
--rw-r--r--  2.0 fat     5724 b- defN 24-Apr-06 22:15 cat_win/tests/test_converter.py
--rw-r--r--  2.0 fat    18785 b- defN 24-Apr-06 22:15 cat_win/tests/test_editor.py
--rw-r--r--  2.0 fat     1047 b- defN 24-Apr-06 22:15 cat_win/tests/test_file.py
--rw-r--r--  2.0 fat     2084 b- defN 24-Apr-06 22:15 cat_win/tests/test_fileattributes.py
--rw-r--r--  2.0 fat    11109 b- defN 24-Apr-06 22:15 cat_win/tests/test_full.py
--rw-r--r--  2.0 fat     7608 b- defN 24-Apr-06 22:15 cat_win/tests/test_holder.py
--rw-r--r--  2.0 fat     6397 b- defN 24-Apr-06 22:15 cat_win/tests/test_more.py
--rw-r--r--  2.0 fat     7461 b- defN 24-Apr-06 22:15 cat_win/tests/test_rawviewer.py
--rw-r--r--  2.0 fat     5622 b- defN 24-Apr-06 22:15 cat_win/tests/test_shell.py
--rw-r--r--  2.0 fat     1240 b- defN 24-Apr-06 22:15 cat_win/tests/test_stdinhelper.py
--rw-r--r--  2.0 fat     3448 b- defN 24-Apr-06 22:15 cat_win/tests/test_stringfinder.py
--rw-r--r--  2.0 fat     2374 b- defN 24-Apr-06 22:15 cat_win/tests/test_strings.py
--rw-r--r--  2.0 fat     2372 b- defN 24-Apr-06 22:15 cat_win/tests/test_summary.py
--rw-r--r--  2.0 fat     4212 b- defN 24-Apr-06 22:15 cat_win/tests/test_updatechecker.py
--rw-r--r--  2.0 fat     1699 b- defN 24-Apr-06 22:15 cat_win/tests/test_urls.py
--rw-r--r--  2.0 fat     5874 b- defN 24-Apr-06 22:15 cat_win/tests/test_utility.py
--rw-r--r--  2.0 fat     1519 b- defN 24-Apr-06 22:15 cat_win/tests/test_zipviewer.py
--rw-r--r--  2.0 fat        0 b- defN 24-Apr-06 22:15 cat_win/tests/mocks/__init__.py
--rw-r--r--  2.0 fat       74 b- defN 24-Apr-06 22:15 cat_win/tests/mocks/edit.py
--rw-r--r--  2.0 fat      330 b- defN 24-Apr-06 22:15 cat_win/tests/mocks/error.py
--rw-r--r--  2.0 fat     3010 b- defN 24-Apr-06 22:15 cat_win/tests/mocks/std.py
--rw-r--r--  2.0 fat    15965 b- defN 24-Apr-06 22:15 cat_win/tests/resources/test.bin
--rw-r--r--  2.0 fat      363 b- defN 24-Apr-06 22:15 cat_win/tests/resources/test.zip
--rw-r--r--  2.0 fat      156 b- defN 24-Apr-06 22:15 cat_win/tests/texts/ansi-base.txt
--rw-r--r--  2.0 fat      246 b- defN 24-Apr-06 22:15 cat_win/tests/texts/ansi-neg.txt
--rw-r--r--  2.0 fat      426 b- defN 24-Apr-06 22:15 cat_win/tests/texts/ansi-pos.txt
--rw-r--r--  2.0 fat       20 b- defN 24-Apr-06 22:15 cat_win/tests/texts/full_test_eval.txt
--rw-r--r--  2.0 fat      170 b- defN 24-Apr-06 22:15 cat_win/tests/texts/full_test_result_B.txt
--rw-r--r--  2.0 fat      196 b- defN 24-Apr-06 22:15 cat_win/tests/texts/full_test_result_C.txt
--rw-r--r--  2.0 fat      141 b- defN 24-Apr-06 22:15 cat_win/tests/texts/full_test_result_D.txt
--rw-r--r--  2.0 fat      189 b- defN 24-Apr-06 22:15 cat_win/tests/texts/test.txt
--rw-r--r--  2.0 fat       14 b- defN 24-Apr-06 22:15 cat_win/tests/texts/test_editor.txt
--rw-r--r--  2.0 fat        0 b- defN 24-Apr-06 22:15 cat_win/tests/texts/test_empty.txt
--rw-r--r--  2.0 fat       19 b- defN 24-Apr-06 22:15 cat_win/tests/texts/test_holderEdgeCase_1.txt
--rw-r--r--  2.0 fat       21 b- defN 24-Apr-06 22:15 cat_win/tests/texts/test_holderEdgeCase_2.txt
--rw-r--r--  2.0 fat       28 b- defN 24-Apr-06 22:15 cat_win/tests/texts/test_holderEdgeCase_3.txt
--rw-r--r--  2.0 fat       10 b- defN 24-Apr-06 22:15 cat_win/tests/texts/test_holderEdgeCase_4.txt
--rw-r--r--  2.0 fat        4 b- defN 24-Apr-06 22:15 cat_win/tests/texts/test_oneline.txt
--rw-r--r--  2.0 fat       62 b- defN 24-Apr-06 22:15 cat_win/tests/texts/test_peek.txt
--rw-r--r--  2.0 fat        0 b- defN 24-Apr-06 22:15 cat_win/util/__init__.py
--rw-r--r--  2.0 fat    13161 b- defN 24-Apr-06 22:15 cat_win/util/argparser.py
--rw-r--r--  2.0 fat     8765 b- defN 24-Apr-06 22:15 cat_win/util/holder.py
--rw-r--r--  2.0 fat        0 b- defN 24-Apr-06 22:15 cat_win/util/helper/__init__.py
--rw-r--r--  2.0 fat    13795 b- defN 24-Apr-06 22:15 cat_win/util/helper/editorhelper.py
--rw-r--r--  2.0 fat      824 b- defN 24-Apr-06 22:15 cat_win/util/helper/file.py
--rw-r--r--  2.0 fat     8516 b- defN 24-Apr-06 22:15 cat_win/util/helper/stdinhelper.py
--rw-r--r--  2.0 fat      703 b- defN 24-Apr-06 22:15 cat_win/util/helper/tmpfilehelper.py
--rw-r--r--  2.0 fat     2002 b- defN 24-Apr-06 22:15 cat_win/util/helper/utility.py
--rw-r--r--  2.0 fat     2172 b- defN 24-Apr-06 22:15 cat_win/util/helper/utilityold.py
--rw-r--r--  2.0 fat     1942 b- defN 24-Apr-06 22:15 cat_win/util/helper/winstreams.py
--rw-r--r--  2.0 fat     1396 b- defN 24-Apr-06 22:15 cat_win/util/helper/zipviewer.py
--rw-r--r--  2.0 fat        0 b- defN 24-Apr-06 22:15 cat_win/util/service/__init__.py
--rw-r--r--  2.0 fat     3004 b- defN 24-Apr-06 22:15 cat_win/util/service/cbase64.py
--rw-r--r--  2.0 fat     2193 b- defN 24-Apr-06 22:15 cat_win/util/service/checksum.py
--rw-r--r--  2.0 fat     9991 b- defN 24-Apr-06 22:15 cat_win/util/service/converter.py
--rw-r--r--  2.0 fat    38690 b- defN 24-Apr-06 22:15 cat_win/util/service/editor.py
--rw-r--r--  2.0 fat     5096 b- defN 24-Apr-06 22:15 cat_win/util/service/fileattributes.py
--rw-r--r--  2.0 fat     2141 b- defN 24-Apr-06 22:15 cat_win/util/service/formatter.py
--rw-r--r--  2.0 fat     8476 b- defN 24-Apr-06 22:15 cat_win/util/service/more.py
--rw-r--r--  2.0 fat     4897 b- defN 24-Apr-06 22:15 cat_win/util/service/rawviewer.py
--rw-r--r--  2.0 fat     4421 b- defN 24-Apr-06 22:15 cat_win/util/service/stringfinder.py
--rw-r--r--  2.0 fat     1179 b- defN 24-Apr-06 22:15 cat_win/util/service/strings.py
--rw-r--r--  2.0 fat     8158 b- defN 24-Apr-06 22:15 cat_win/util/service/summary.py
--rw-r--r--  2.0 fat        0 b- defN 24-Apr-06 22:15 cat_win/web/__init__.py
--rw-r--r--  2.0 fat     6832 b- defN 24-Apr-06 22:15 cat_win/web/updatechecker.py
--rw-r--r--  2.0 fat     2527 b- defN 24-Apr-06 22:15 cat_win/web/urls.py
--rw-r--r--  2.0 fat       93 b- defN 16-Jan-01 00:00 cat_win-1.7.5.dist-info/entry_points.txt
--rw-r--r--  2.0 fat     1090 b- defN 24-Apr-06 20:21 cat_win-1.7.5.dist-info/LICENSE
--rw-r--r--  2.0 fat       81 b- defN 16-Jan-01 00:00 cat_win-1.7.5.dist-info/WHEEL
--rw-r--r--  2.0 fat    11969 b- defN 16-Jan-01 00:00 cat_win-1.7.5.dist-info/METADATA
--rw-r--r--  2.0 fat     7881 b- defN 16-Jan-01 00:00 cat_win-1.7.5.dist-info/RECORD
-91 files, 403577 bytes uncompressed, 95887 bytes compressed:  76.2%
+Zip file size: 113452 bytes, number of entries: 102
+-rw-r--r--  2.0 fat      305 b- defN 24-Apr-23 17:31 cat_win/__init__.py
+-rw-r--r--  2.0 fat      487 b- defN 24-Apr-16 17:07 cat_win/__main__.py
+-rw-r--r--  2.0 fat      395 b- defN 24-Apr-16 17:07 cat_win/shell.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/src/__init__.py
+-rw-r--r--  2.0 fat    12543 b- defN 24-Apr-21 12:35 cat_win/src/argparser.py
+-rw-r--r--  2.0 fat    51723 b- defN 24-Apr-23 17:39 cat_win/src/cat.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-16 16:22 cat_win/src/const/__init__.py
+-rw-r--r--  2.0 fat     9430 b- defN 24-Apr-20 23:27 cat_win/src/const/argconstants.py
+-rw-r--r--  2.0 fat     2661 b- defN 24-Apr-07 13:10 cat_win/src/const/colorconstants.py
+-rw-r--r--  2.0 fat      740 b- defN 24-Apr-20 23:49 cat_win/src/const/defaultconstants.py
+-rw-r--r--  2.0 fat     2583 b- defN 24-Apr-16 16:22 cat_win/src/const/regex.py
+-rw-r--r--  2.0 fat     3289 b- defN 24-Apr-19 00:29 cat_win/src/domain/arguments.py
+-rw-r--r--  2.0 fat      824 b- defN 24-Apr-16 16:22 cat_win/src/domain/file.py
+-rw-r--r--  2.0 fat     5420 b- defN 24-Apr-20 17:17 cat_win/src/domain/files.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-16 16:22 cat_win/src/persistence/__init__.py
+-rw-r--r--  2.0 fat    11316 b- defN 24-Apr-20 23:19 cat_win/src/persistence/cconfig.py
+-rw-r--r--  2.0 fat    10976 b- defN 24-Apr-21 00:08 cat_win/src/persistence/config.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/src/service/__init__.py
+-rw-r--r--  2.0 fat     2193 b- defN 24-Apr-10 16:18 cat_win/src/service/cbase64.py
+-rw-r--r--  2.0 fat     2193 b- defN 24-Apr-07 13:10 cat_win/src/service/checksum.py
+-rw-r--r--  2.0 fat     2370 b- defN 24-Apr-19 13:40 cat_win/src/service/clipboard.py
+-rw-r--r--  2.0 fat     8872 b- defN 24-Apr-21 12:33 cat_win/src/service/converter.py
+-rw-r--r--  2.0 fat    38209 b- defN 24-Apr-21 00:30 cat_win/src/service/editor.py
+-rw-r--r--  2.0 fat     5103 b- defN 24-Apr-16 16:34 cat_win/src/service/fileattributes.py
+-rw-r--r--  2.0 fat     2141 b- defN 24-Apr-07 13:10 cat_win/src/service/formatter.py
+-rw-r--r--  2.0 fat     8486 b- defN 24-Apr-19 13:48 cat_win/src/service/more.py
+-rw-r--r--  2.0 fat     4922 b- defN 24-Apr-19 14:17 cat_win/src/service/rawviewer.py
+-rw-r--r--  2.0 fat     4290 b- defN 24-Apr-16 16:25 cat_win/src/service/stringfinder.py
+-rw-r--r--  2.0 fat     1295 b- defN 24-Apr-21 00:08 cat_win/src/service/strings.py
+-rw-r--r--  2.0 fat     8242 b- defN 24-Apr-19 14:16 cat_win/src/service/summary.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/src/service/helper/__init__.py
+-rw-r--r--  2.0 fat    13795 b- defN 24-Apr-07 13:10 cat_win/src/service/helper/editorhelper.py
+-rw-r--r--  2.0 fat    11311 b- defN 24-Apr-23 15:56 cat_win/src/service/helper/iohelper.py
+-rw-r--r--  2.0 fat      703 b- defN 24-Apr-07 13:10 cat_win/src/service/helper/tmpfilehelper.py
+-rw-r--r--  2.0 fat     2001 b- defN 24-Apr-16 16:30 cat_win/src/service/helper/utility.py
+-rw-r--r--  2.0 fat     2171 b- defN 24-Apr-16 16:30 cat_win/src/service/helper/utilityold.py
+-rw-r--r--  2.0 fat     1942 b- defN 24-Apr-07 13:10 cat_win/src/service/helper/winstreams.py
+-rw-r--r--  2.0 fat     1406 b- defN 24-Apr-19 13:55 cat_win/src/service/helper/zipviewer.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/src/web/__init__.py
+-rw-r--r--  2.0 fat     6882 b- defN 24-Apr-19 13:41 cat_win/src/web/updatechecker.py
+-rw-r--r--  2.0 fat     2224 b- defN 24-Apr-16 16:24 cat_win/src/web/urls.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/tests/__init__.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/tests/mocks/__init__.py
+-rw-r--r--  2.0 fat       74 b- defN 24-Apr-07 13:10 cat_win/tests/mocks/edit.py
+-rw-r--r--  2.0 fat      330 b- defN 24-Apr-07 13:10 cat_win/tests/mocks/error.py
+-rw-r--r--  2.0 fat     3010 b- defN 24-Apr-07 13:10 cat_win/tests/mocks/std.py
+-rw-r--r--  2.0 fat    15965 b- defN 24-Apr-07 13:10 cat_win/tests/resources/test.bin
+-rw-r--r--  2.0 fat      363 b- defN 24-Apr-07 13:10 cat_win/tests/resources/test.zip
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/tests/src/__init__.py
+-rw-r--r--  2.0 fat     4568 b- defN 24-Apr-16 17:08 cat_win/tests/src/test_ansi.py
+-rw-r--r--  2.0 fat    12675 b- defN 24-Apr-19 00:47 cat_win/tests/src/test_argparser.py
+-rw-r--r--  2.0 fat     9048 b- defN 24-Apr-19 00:00 cat_win/tests/src/test_cat.py
+-rw-r--r--  2.0 fat    11179 b- defN 24-Apr-16 17:08 cat_win/tests/src/test_full.py
+-rw-r--r--  2.0 fat     5798 b- defN 24-Apr-19 13:51 cat_win/tests/src/test_shell.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/tests/src/const/__init__.py
+-rw-r--r--  2.0 fat     1191 b- defN 24-Apr-16 16:24 cat_win/tests/src/const/test_argconstants.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/tests/src/domain/__init__.py
+-rw-r--r--  2.0 fat     3418 b- defN 24-Apr-19 00:18 cat_win/tests/src/domain/test_arguments.py
+-rw-r--r--  2.0 fat     1046 b- defN 24-Apr-16 16:26 cat_win/tests/src/domain/test_file.py
+-rw-r--r--  2.0 fat     4413 b- defN 24-Apr-19 00:17 cat_win/tests/src/domain/test_files.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/tests/src/persistence/__init__.py
+-rw-r--r--  2.0 fat     1572 b- defN 24-Apr-16 16:25 cat_win/tests/src/persistence/test_cconfig.py
+-rw-r--r--  2.0 fat     3301 b- defN 24-Apr-16 16:25 cat_win/tests/src/persistence/test_config.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/tests/src/service/__init__.py
+-rw-r--r--  2.0 fat     1953 b- defN 24-Apr-16 16:27 cat_win/tests/src/service/test_cbase64.py
+-rw-r--r--  2.0 fat     1774 b- defN 24-Apr-16 16:54 cat_win/tests/src/service/test_checksum.py
+-rw-r--r--  2.0 fat     5723 b- defN 24-Apr-16 16:30 cat_win/tests/src/service/test_converter.py
+-rw-r--r--  2.0 fat    18545 b- defN 24-Apr-19 14:20 cat_win/tests/src/service/test_editor.py
+-rw-r--r--  2.0 fat     2083 b- defN 24-Apr-16 16:30 cat_win/tests/src/service/test_fileattributes.py
+-rw-r--r--  2.0 fat     6395 b- defN 24-Apr-16 16:56 cat_win/tests/src/service/test_more.py
+-rw-r--r--  2.0 fat     7472 b- defN 24-Apr-16 16:56 cat_win/tests/src/service/test_rawviewer.py
+-rw-r--r--  2.0 fat     3816 b- defN 24-Apr-16 16:29 cat_win/tests/src/service/test_stringfinder.py
+-rw-r--r--  2.0 fat     2385 b- defN 24-Apr-16 16:58 cat_win/tests/src/service/test_strings.py
+-rw-r--r--  2.0 fat     2382 b- defN 24-Apr-16 16:58 cat_win/tests/src/service/test_summary.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/tests/src/service/helper/__init__.py
+-rw-r--r--  2.0 fat     1832 b- defN 24-Apr-19 14:27 cat_win/tests/src/service/helper/test_iohelper.py
+-rw-r--r--  2.0 fat     5895 b- defN 24-Apr-16 17:07 cat_win/tests/src/service/helper/test_utility.py
+-rw-r--r--  2.0 fat     1579 b- defN 24-Apr-16 17:01 cat_win/tests/src/service/helper/test_zipviewer.py
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/tests/src/web/__init__.py
+-rw-r--r--  2.0 fat     4216 b- defN 24-Apr-16 16:23 cat_win/tests/src/web/test_updatechecker.py
+-rw-r--r--  2.0 fat     1703 b- defN 24-Apr-16 16:23 cat_win/tests/src/web/test_urls.py
+-rw-r--r--  2.0 fat      156 b- defN 24-Apr-07 13:10 cat_win/tests/texts/ansi-base.txt
+-rw-r--r--  2.0 fat      246 b- defN 24-Apr-07 13:10 cat_win/tests/texts/ansi-neg.txt
+-rw-r--r--  2.0 fat      426 b- defN 24-Apr-07 13:10 cat_win/tests/texts/ansi-pos.txt
+-rw-r--r--  2.0 fat       20 b- defN 24-Apr-07 13:10 cat_win/tests/texts/full_test_eval.txt
+-rw-r--r--  2.0 fat      170 b- defN 24-Apr-07 13:10 cat_win/tests/texts/full_test_result_B.txt
+-rw-r--r--  2.0 fat      196 b- defN 24-Apr-07 13:10 cat_win/tests/texts/full_test_result_C.txt
+-rw-r--r--  2.0 fat      141 b- defN 24-Apr-07 13:10 cat_win/tests/texts/full_test_result_D.txt
+-rw-r--r--  2.0 fat      189 b- defN 24-Apr-07 13:10 cat_win/tests/texts/test.txt
+-rw-r--r--  2.0 fat       14 b- defN 24-Apr-07 13:10 cat_win/tests/texts/test_editor.txt
+-rw-r--r--  2.0 fat        0 b- defN 24-Apr-07 13:10 cat_win/tests/texts/test_empty.txt
+-rw-r--r--  2.0 fat       19 b- defN 24-Apr-07 13:10 cat_win/tests/texts/test_holderEdgeCase_1.txt
+-rw-r--r--  2.0 fat       21 b- defN 24-Apr-07 13:10 cat_win/tests/texts/test_holderEdgeCase_2.txt
+-rw-r--r--  2.0 fat       28 b- defN 24-Apr-07 13:10 cat_win/tests/texts/test_holderEdgeCase_3.txt
+-rw-r--r--  2.0 fat       10 b- defN 24-Apr-07 13:10 cat_win/tests/texts/test_holderEdgeCase_4.txt
+-rw-r--r--  2.0 fat        4 b- defN 24-Apr-07 13:10 cat_win/tests/texts/test_oneline.txt
+-rw-r--r--  2.0 fat       62 b- defN 24-Apr-07 13:10 cat_win/tests/texts/test_peek.txt
+-rw-r--r--  2.0 fat       93 b- defN 16-Jan-01 00:00 cat_win-1.7.6.dist-info/entry_points.txt
+-rw-r--r--  2.0 fat     1090 b- defN 24-Apr-06 20:21 cat_win-1.7.6.dist-info/LICENSE
+-rw-r--r--  2.0 fat       81 b- defN 16-Jan-01 00:00 cat_win-1.7.6.dist-info/WHEEL
+-rw-r--r--  2.0 fat    12086 b- defN 16-Jan-01 00:00 cat_win-1.7.6.dist-info/METADATA
+-rw-r--r--  2.0 fat     9235 b- defN 16-Jan-01 00:00 cat_win-1.7.6.dist-info/RECORD
+102 files, 413434 bytes uncompressed, 98580 bytes compressed:  76.2%
```

## zipnote {}

```diff
@@ -1,116 +1,131 @@
 Filename: cat_win/__init__.py
 Comment: 
 
 Filename: cat_win/__main__.py
 Comment: 
 
-Filename: cat_win/cat.py
+Filename: cat_win/shell.py
 Comment: 
 
-Filename: cat_win/shell.py
+Filename: cat_win/src/__init__.py
 Comment: 
 
-Filename: cat_win/const/__init__.py
+Filename: cat_win/src/argparser.py
 Comment: 
 
-Filename: cat_win/const/argconstants.py
+Filename: cat_win/src/cat.py
 Comment: 
 
-Filename: cat_win/const/colorconstants.py
+Filename: cat_win/src/const/__init__.py
 Comment: 
 
-Filename: cat_win/const/defaultconstants.py
+Filename: cat_win/src/const/argconstants.py
 Comment: 
 
-Filename: cat_win/persistence/__init__.py
+Filename: cat_win/src/const/colorconstants.py
 Comment: 
 
-Filename: cat_win/persistence/cconfig.py
+Filename: cat_win/src/const/defaultconstants.py
 Comment: 
 
-Filename: cat_win/persistence/config.py
+Filename: cat_win/src/const/regex.py
 Comment: 
 
-Filename: cat_win/tests/__init__.py
+Filename: cat_win/src/domain/arguments.py
+Comment: 
+
+Filename: cat_win/src/domain/file.py
+Comment: 
+
+Filename: cat_win/src/domain/files.py
 Comment: 
 
-Filename: cat_win/tests/test_ansi.py
+Filename: cat_win/src/persistence/__init__.py
 Comment: 
 
-Filename: cat_win/tests/test_argconstants.py
+Filename: cat_win/src/persistence/cconfig.py
 Comment: 
 
-Filename: cat_win/tests/test_argparser.py
+Filename: cat_win/src/persistence/config.py
 Comment: 
 
-Filename: cat_win/tests/test_cat.py
+Filename: cat_win/src/service/__init__.py
 Comment: 
 
-Filename: cat_win/tests/test_cbase64.py
+Filename: cat_win/src/service/cbase64.py
 Comment: 
 
-Filename: cat_win/tests/test_cconfig.py
+Filename: cat_win/src/service/checksum.py
 Comment: 
 
-Filename: cat_win/tests/test_checksum.py
+Filename: cat_win/src/service/clipboard.py
 Comment: 
 
-Filename: cat_win/tests/test_config.py
+Filename: cat_win/src/service/converter.py
 Comment: 
 
-Filename: cat_win/tests/test_converter.py
+Filename: cat_win/src/service/editor.py
 Comment: 
 
-Filename: cat_win/tests/test_editor.py
+Filename: cat_win/src/service/fileattributes.py
 Comment: 
 
-Filename: cat_win/tests/test_file.py
+Filename: cat_win/src/service/formatter.py
 Comment: 
 
-Filename: cat_win/tests/test_fileattributes.py
+Filename: cat_win/src/service/more.py
 Comment: 
 
-Filename: cat_win/tests/test_full.py
+Filename: cat_win/src/service/rawviewer.py
 Comment: 
 
-Filename: cat_win/tests/test_holder.py
+Filename: cat_win/src/service/stringfinder.py
 Comment: 
 
-Filename: cat_win/tests/test_more.py
+Filename: cat_win/src/service/strings.py
 Comment: 
 
-Filename: cat_win/tests/test_rawviewer.py
+Filename: cat_win/src/service/summary.py
 Comment: 
 
-Filename: cat_win/tests/test_shell.py
+Filename: cat_win/src/service/helper/__init__.py
 Comment: 
 
-Filename: cat_win/tests/test_stdinhelper.py
+Filename: cat_win/src/service/helper/editorhelper.py
 Comment: 
 
-Filename: cat_win/tests/test_stringfinder.py
+Filename: cat_win/src/service/helper/iohelper.py
 Comment: 
 
-Filename: cat_win/tests/test_strings.py
+Filename: cat_win/src/service/helper/tmpfilehelper.py
 Comment: 
 
-Filename: cat_win/tests/test_summary.py
+Filename: cat_win/src/service/helper/utility.py
 Comment: 
 
-Filename: cat_win/tests/test_updatechecker.py
+Filename: cat_win/src/service/helper/utilityold.py
 Comment: 
 
-Filename: cat_win/tests/test_urls.py
+Filename: cat_win/src/service/helper/winstreams.py
 Comment: 
 
-Filename: cat_win/tests/test_utility.py
+Filename: cat_win/src/service/helper/zipviewer.py
 Comment: 
 
-Filename: cat_win/tests/test_zipviewer.py
+Filename: cat_win/src/web/__init__.py
+Comment: 
+
+Filename: cat_win/src/web/updatechecker.py
+Comment: 
+
+Filename: cat_win/src/web/urls.py
+Comment: 
+
+Filename: cat_win/tests/__init__.py
 Comment: 
 
 Filename: cat_win/tests/mocks/__init__.py
 Comment: 
 
 Filename: cat_win/tests/mocks/edit.py
 Comment: 
@@ -123,152 +138,170 @@
 
 Filename: cat_win/tests/resources/test.bin
 Comment: 
 
 Filename: cat_win/tests/resources/test.zip
 Comment: 
 
-Filename: cat_win/tests/texts/ansi-base.txt
+Filename: cat_win/tests/src/__init__.py
 Comment: 
 
-Filename: cat_win/tests/texts/ansi-neg.txt
+Filename: cat_win/tests/src/test_ansi.py
 Comment: 
 
-Filename: cat_win/tests/texts/ansi-pos.txt
+Filename: cat_win/tests/src/test_argparser.py
 Comment: 
 
-Filename: cat_win/tests/texts/full_test_eval.txt
+Filename: cat_win/tests/src/test_cat.py
 Comment: 
 
-Filename: cat_win/tests/texts/full_test_result_B.txt
+Filename: cat_win/tests/src/test_full.py
 Comment: 
 
-Filename: cat_win/tests/texts/full_test_result_C.txt
+Filename: cat_win/tests/src/test_shell.py
 Comment: 
 
-Filename: cat_win/tests/texts/full_test_result_D.txt
+Filename: cat_win/tests/src/const/__init__.py
 Comment: 
 
-Filename: cat_win/tests/texts/test.txt
+Filename: cat_win/tests/src/const/test_argconstants.py
 Comment: 
 
-Filename: cat_win/tests/texts/test_editor.txt
+Filename: cat_win/tests/src/domain/__init__.py
 Comment: 
 
-Filename: cat_win/tests/texts/test_empty.txt
+Filename: cat_win/tests/src/domain/test_arguments.py
 Comment: 
 
-Filename: cat_win/tests/texts/test_holderEdgeCase_1.txt
+Filename: cat_win/tests/src/domain/test_file.py
 Comment: 
 
-Filename: cat_win/tests/texts/test_holderEdgeCase_2.txt
+Filename: cat_win/tests/src/domain/test_files.py
 Comment: 
 
-Filename: cat_win/tests/texts/test_holderEdgeCase_3.txt
+Filename: cat_win/tests/src/persistence/__init__.py
 Comment: 
 
-Filename: cat_win/tests/texts/test_holderEdgeCase_4.txt
+Filename: cat_win/tests/src/persistence/test_cconfig.py
 Comment: 
 
-Filename: cat_win/tests/texts/test_oneline.txt
+Filename: cat_win/tests/src/persistence/test_config.py
 Comment: 
 
-Filename: cat_win/tests/texts/test_peek.txt
+Filename: cat_win/tests/src/service/__init__.py
 Comment: 
 
-Filename: cat_win/util/__init__.py
+Filename: cat_win/tests/src/service/test_cbase64.py
 Comment: 
 
-Filename: cat_win/util/argparser.py
+Filename: cat_win/tests/src/service/test_checksum.py
 Comment: 
 
-Filename: cat_win/util/holder.py
+Filename: cat_win/tests/src/service/test_converter.py
 Comment: 
 
-Filename: cat_win/util/helper/__init__.py
+Filename: cat_win/tests/src/service/test_editor.py
 Comment: 
 
-Filename: cat_win/util/helper/editorhelper.py
+Filename: cat_win/tests/src/service/test_fileattributes.py
 Comment: 
 
-Filename: cat_win/util/helper/file.py
+Filename: cat_win/tests/src/service/test_more.py
 Comment: 
 
-Filename: cat_win/util/helper/stdinhelper.py
+Filename: cat_win/tests/src/service/test_rawviewer.py
 Comment: 
 
-Filename: cat_win/util/helper/tmpfilehelper.py
+Filename: cat_win/tests/src/service/test_stringfinder.py
 Comment: 
 
-Filename: cat_win/util/helper/utility.py
+Filename: cat_win/tests/src/service/test_strings.py
 Comment: 
 
-Filename: cat_win/util/helper/utilityold.py
+Filename: cat_win/tests/src/service/test_summary.py
 Comment: 
 
-Filename: cat_win/util/helper/winstreams.py
+Filename: cat_win/tests/src/service/helper/__init__.py
 Comment: 
 
-Filename: cat_win/util/helper/zipviewer.py
+Filename: cat_win/tests/src/service/helper/test_iohelper.py
 Comment: 
 
-Filename: cat_win/util/service/__init__.py
+Filename: cat_win/tests/src/service/helper/test_utility.py
 Comment: 
 
-Filename: cat_win/util/service/cbase64.py
+Filename: cat_win/tests/src/service/helper/test_zipviewer.py
 Comment: 
 
-Filename: cat_win/util/service/checksum.py
+Filename: cat_win/tests/src/web/__init__.py
 Comment: 
 
-Filename: cat_win/util/service/converter.py
+Filename: cat_win/tests/src/web/test_updatechecker.py
 Comment: 
 
-Filename: cat_win/util/service/editor.py
+Filename: cat_win/tests/src/web/test_urls.py
 Comment: 
 
-Filename: cat_win/util/service/fileattributes.py
+Filename: cat_win/tests/texts/ansi-base.txt
 Comment: 
 
-Filename: cat_win/util/service/formatter.py
+Filename: cat_win/tests/texts/ansi-neg.txt
 Comment: 
 
-Filename: cat_win/util/service/more.py
+Filename: cat_win/tests/texts/ansi-pos.txt
 Comment: 
 
-Filename: cat_win/util/service/rawviewer.py
+Filename: cat_win/tests/texts/full_test_eval.txt
 Comment: 
 
-Filename: cat_win/util/service/stringfinder.py
+Filename: cat_win/tests/texts/full_test_result_B.txt
 Comment: 
 
-Filename: cat_win/util/service/strings.py
+Filename: cat_win/tests/texts/full_test_result_C.txt
 Comment: 
 
-Filename: cat_win/util/service/summary.py
+Filename: cat_win/tests/texts/full_test_result_D.txt
 Comment: 
 
-Filename: cat_win/web/__init__.py
+Filename: cat_win/tests/texts/test.txt
 Comment: 
 
-Filename: cat_win/web/updatechecker.py
+Filename: cat_win/tests/texts/test_editor.txt
 Comment: 
 
-Filename: cat_win/web/urls.py
+Filename: cat_win/tests/texts/test_empty.txt
+Comment: 
+
+Filename: cat_win/tests/texts/test_holderEdgeCase_1.txt
+Comment: 
+
+Filename: cat_win/tests/texts/test_holderEdgeCase_2.txt
+Comment: 
+
+Filename: cat_win/tests/texts/test_holderEdgeCase_3.txt
+Comment: 
+
+Filename: cat_win/tests/texts/test_holderEdgeCase_4.txt
+Comment: 
+
+Filename: cat_win/tests/texts/test_oneline.txt
+Comment: 
+
+Filename: cat_win/tests/texts/test_peek.txt
 Comment: 
 
-Filename: cat_win-1.7.5.dist-info/entry_points.txt
+Filename: cat_win-1.7.6.dist-info/entry_points.txt
 Comment: 
 
-Filename: cat_win-1.7.5.dist-info/LICENSE
+Filename: cat_win-1.7.6.dist-info/LICENSE
 Comment: 
 
-Filename: cat_win-1.7.5.dist-info/WHEEL
+Filename: cat_win-1.7.6.dist-info/WHEEL
 Comment: 
 
-Filename: cat_win-1.7.5.dist-info/METADATA
+Filename: cat_win-1.7.6.dist-info/METADATA
 Comment: 
 
-Filename: cat_win-1.7.5.dist-info/RECORD
+Filename: cat_win-1.7.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cat_win/__init__.py

```diff
@@ -1,7 +1,7 @@
 """Simple OS Independent 'cat' Command-line Tool made in Python."""
 
 __project__ = 'cat_win'
-__version__ = '1.7.5'
+__version__ = '1.7.6'
 __sysversion__ = '3.12.2 (tags/v3.12.2:6abddd9, Feb  6 2024, 21:26:36) [MSC v.1937 64 bit (AMD64)]'
 __author__ = 'Silas A. Kraume'
 __url__ = 'https://github.com/SilenZcience/cat_win'
```

## cat_win/__main__.py

```diff
@@ -2,15 +2,15 @@
 __main__
 """
 
 import sys
 
 
 try:
-    from cat_win import cat
+    from cat_win.src import cat
 except KeyboardInterrupt:
     sys.exit(1)
 except Exception as e:
     print('an error occured while loading the module:', file=sys.stderr)
     print(e, file=sys.stderr)
     sys.exit(1)
```

## cat_win/shell.py

```diff
@@ -2,15 +2,15 @@
 shell
 """
 
 import sys
 
 
 try:
-    from cat_win import cat
+    from cat_win.src import cat
 except KeyboardInterrupt:
     sys.exit(1)
 except Exception as e:
     print('an error occured while loading the module:', file=sys.stderr)
     print(e, file=sys.stderr)
     sys.exit(1)
```

## Comparing `cat_win/cat.py` & `cat_win/src/cat.py`

 * *Files 19% similar despite different names*

```diff
@@ -8,120 +8,115 @@
     nop = lambda *_, **__: None; coloramaInit = nop
 from datetime import datetime
 from functools import lru_cache
 from itertools import groupby
 from time import monotonic
 import os
 import platform
-import re
+import shlex
 import sys
 
-from cat_win.const.argconstants import ALL_ARGS, ARGS_EDITOR, ARGS_WORDCOUNT, ARGS_WWORDCOUNT
-from cat_win.const.argconstants import ARGS_HELP, ARGS_NUMBER, ARGS_ENDS, ARGS_SQUEEZE
-from cat_win.const.argconstants import ARGS_REVERSE, ARGS_SUM, ARGS_BLANK, ARGS_FILES
-from cat_win.const.argconstants import ARGS_STDIN, ARGS_NOCOL, ARGS_BINVIEW, ARGS_FILE_PREFIX
-from cat_win.const.argconstants import ARGS_CLIP, ARGS_CHECKSUM, ARGS_DEC, ARGS_HEX, ARGS_BIN
-from cat_win.const.argconstants import ARGS_VERSION, ARGS_DEBUG, ARGS_CUT, ARGS_REPLACE, ARGS_DATA
-from cat_win.const.argconstants import ARGS_CCONFIG, ARGS_LLENGTH, ARGS_ONELINE, ARGS_PEEK
-from cat_win.const.argconstants import ARGS_CHR, ARGS_B64E, ARGS_B64D, ARGS_FFILES, ARGS_GREP
-from cat_win.const.argconstants import ARGS_NOBREAK, ARGS_ECHO, ARGS_SSUM, ARGS_HEXVIEW
-from cat_win.const.argconstants import ARGS_NOKEYWORD, ARGS_RECONFIGURE, ARGS_RECONFIGURE_IN
-from cat_win.const.argconstants import ARGS_RECONFIGURE_OUT, ARGS_RECONFIGURE_ERR, ARGS_CONFIG
-from cat_win.const.argconstants import ARGS_EVAL, ARGS_SORT, ARGS_GREP_ONLY, ARGS_PLAIN_ONLY
-from cat_win.const.argconstants import ARGS_FFILE_PREFIX, ARGS_DOTFILES, ARGS_OCT, ARGS_URI
-from cat_win.const.argconstants import ARGS_DIRECTORIES, ARGS_DDIRECTORIES, ARGS_SPECIFIC_FORMATS
-from cat_win.const.argconstants import ARGS_CHARCOUNT, ARGS_CCHARCOUNT, ARGS_STRINGS, ARGS_MORE
-from cat_win.const.colorconstants import CKW
-from cat_win.const.defaultconstants import DKW
-from cat_win.persistence.cconfig import CConfig
-from cat_win.persistence.config import Config
-from cat_win.util.argparser import ArgParser
-from cat_win.util.holder import Holder
-from cat_win.util.helper.tmpfilehelper import TmpFileHelper
+from cat_win.src.argparser import ArgParser
+from cat_win.src.const.argconstants import ALL_ARGS, ARGS_EDITOR, ARGS_WORDCOUNT, ARGS_WWORDCOUNT
+from cat_win.src.const.argconstants import ARGS_HELP, ARGS_NUMBER, ARGS_ENDS, ARGS_SQUEEZE
+from cat_win.src.const.argconstants import ARGS_REVERSE, ARGS_SUM, ARGS_BLANK, ARGS_FILES, ARGS_RAW
+from cat_win.src.const.argconstants import ARGS_STDIN, ARGS_NOCOL, ARGS_BINVIEW, ARGS_FILE_PREFIX
+from cat_win.src.const.argconstants import ARGS_CLIP, ARGS_CHECKSUM, ARGS_DEC, ARGS_HEX, ARGS_BIN
+from cat_win.src.const.argconstants import ARGS_VERSION, ARGS_DEBUG, ARGS_CUT, ARGS_REPLACE, ARGS_DATA
+from cat_win.src.const.argconstants import ARGS_CCONFIG, ARGS_LLENGTH, ARGS_ONELINE, ARGS_PEEK
+from cat_win.src.const.argconstants import ARGS_CHR, ARGS_B64E, ARGS_B64D, ARGS_FFILES, ARGS_GREP
+from cat_win.src.const.argconstants import ARGS_NOBREAK, ARGS_ECHO, ARGS_SSUM, ARGS_HEXVIEW
+from cat_win.src.const.argconstants import ARGS_NOKEYWORD, ARGS_RECONFIGURE, ARGS_RECONFIGURE_IN
+from cat_win.src.const.argconstants import ARGS_RECONFIGURE_OUT, ARGS_RECONFIGURE_ERR, ARGS_CONFIG
+from cat_win.src.const.argconstants import ARGS_EVAL, ARGS_SORT, ARGS_GREP_ONLY, ARGS_PLAIN_ONLY
+from cat_win.src.const.argconstants import ARGS_FFILE_PREFIX, ARGS_DOTFILES, ARGS_OCT, ARGS_URI
+from cat_win.src.const.argconstants import ARGS_DIRECTORIES, ARGS_DDIRECTORIES, ARGS_SPECIFIC_FORMATS
+from cat_win.src.const.argconstants import ARGS_CHARCOUNT, ARGS_CCHARCOUNT, ARGS_STRINGS, ARGS_MORE
+from cat_win.src.const.argconstants import ARGS_CONFIG_FLUSH, ARGS_CCONFIG_FLUSH, ARGS_CONFIG_REMOVE
+from cat_win.src.const.colorconstants import CKW
+from cat_win.src.const.defaultconstants import DKW
+from cat_win.src.const.regex import ANSI_CSI_RE
+from cat_win.src.domain.arguments import Arguments
+from cat_win.src.domain.files import Files
+from cat_win.src.persistence.cconfig import CConfig
+from cat_win.src.persistence.config import Config
+from cat_win.src.service.helper.tmpfilehelper import TmpFileHelper
 try:
-    from cat_win.util.helper.utility import comp_eval, comp_conv
+    from cat_win.src.service.helper.utility import comp_eval, comp_conv
 except SyntaxError: # in case of Python 3.7
-    from cat_win.util.helper.utilityold import comp_eval, comp_conv
-from cat_win.util.helper.zipviewer import display_zip
-from cat_win.util.helper import stdinhelper
-from cat_win.util.service.cbase64 import _decode_base64, encode_base64
-from cat_win.util.service.checksum import print_checksum
-from cat_win.util.service.converter import Converter
-from cat_win.util.service.editor import Editor
-from cat_win.util.service.fileattributes import get_file_size, get_file_mtime, print_meta
-from cat_win.util.service.fileattributes import _convert_size
-from cat_win.util.service.formatter import Formatter
-from cat_win.util.service.more import More
-from cat_win.util.service.rawviewer import SPECIAL_CHARS, get_raw_view_lines_gen
-from cat_win.util.service.stringfinder import StringFinder
-from cat_win.util.service.strings import get_strings
-from cat_win.util.service.summary import Summary
-from cat_win.web.updatechecker import print_update_information
-from cat_win.web.urls import sep_valid_urls, read_url
+    from cat_win.src.service.helper.utilityold import comp_eval, comp_conv
+from cat_win.src.service.helper.zipviewer import display_zip
+from cat_win.src.service.helper.iohelper import IoHelper, err_print
+from cat_win.src.service.cbase64 import encode_base64, decode_base64
+from cat_win.src.service.checksum import print_checksum
+from cat_win.src.service.clipboard import Clipboard
+from cat_win.src.service.converter import Converter
+from cat_win.src.service.editor import Editor
+from cat_win.src.service.fileattributes import get_file_size, get_file_mtime, print_meta
+from cat_win.src.service.fileattributes import _convert_size
+from cat_win.src.service.formatter import Formatter
+from cat_win.src.service.more import More
+from cat_win.src.service.rawviewer import SPECIAL_CHARS, get_raw_view_lines_gen
+from cat_win.src.service.stringfinder import StringFinder
+from cat_win.src.service.strings import get_strings
+from cat_win.src.service.summary import Summary
+from cat_win.src.web.updatechecker import print_update_information
+from cat_win.src.web.urls import sep_valid_urls, read_url
 from cat_win import __project__, __version__, __sysversion__, __author__, __url__
 
 
 coloramaInit(strip=False)
-working_dir = os.path.dirname(os.path.realpath(__file__))
+working_dir = os.path.abspath(os.path.join(os.path.realpath(__file__), os.pardir, os.pardir))
 
 on_windows_os = platform.system() == 'Windows'
 file_uri_prefix = 'file://' + '/' * on_windows_os
-ANSI_CSI_RE = re.compile(r'\001?\033\[(?:\d|;)*[a-zA-Z]\002?') # Control Sequence Introducer
-# ANSI_OSC_RE = re.compile(r'\001?\033\]([^\a]*)(\a)\002?')    # Operating System Command
 
 cconfig = CConfig(working_dir)
 config = Config(working_dir)
 
 default_color_dic, color_dic, const_dic = None, None, None
 
-arg_parser, converter, holder, tmp_file_helper = None, None, None, None
+arg_parser, u_args, u_files, converter, = None, None, None, None
 
 
 def setup():
     """
     setup the global variables.
     """
     global default_color_dic, color_dic, const_dic
-    global arg_parser, converter, holder, tmp_file_helper
+    global arg_parser, converter, u_files, u_args
 
     default_color_dic = cconfig.load_config()
     color_dic = default_color_dic.copy()
     const_dic = config.load_config()
 
     arg_parser = ArgParser(const_dic[DKW.DEFAULT_FILE_ENCODING],
                            const_dic[DKW.UNICODE_ESCAPED_FIND],
                            const_dic[DKW.UNICODE_ESCAPED_REPLACE])
+    u_args = Arguments()
+    u_files = Files()
     converter = Converter()
-    holder = Holder()
-    tmp_file_helper = TmpFileHelper()
     Summary.setup_colors(color_dic[CKW.SUMMARY], color_dic[CKW.RESET_ALL])
     More.setup(on_windows_os, const_dic[DKW.MORE_STEP_LENGTH])
 
 
-def err_print(*args, **kwargs):
-    """
-    print to stderr.
-    """
-    print(*args, file=sys.stderr, flush=True, **kwargs)
-
-
 def exception_handler(exception_type: type, exception, traceback,
                       debug_hook=sys.excepthook) -> None:
     """
     custom exception handler.
     """
     # STATUS_PIPE_CLOSING can map to WinAPI EINVAL (errno: 22)
     if isinstance(exception, BrokenPipeError) or \
         isinstance(exception, OSError) and exception.errno == 22:
         devnull = os.open(os.devnull, os.O_WRONLY)
         os.dup2(devnull, sys.stdout.fileno())
         sys.exit(1)  # Python exits with error code 1 on EPIPE
     try:
         err_print(color_dic[CKW.RESET_ALL])
-        if holder.args_id[ARGS_DEBUG]:
+        if u_args[ARGS_DEBUG]:
             return debug_hook(exception_type, exception, traceback)
         err_print(f"\n{exception_type.__name__}{':' * bool(str(exception))} {exception}")
         if exception_type != KeyboardInterrupt:
             err_print('If this Exception is unexpected, please raise an official Issue at:')
             err_print(f"{__url__}/issues")
         sys.exit(0)
     except BrokenPipeError: # we only used stderr in the try-block, so it has to be the broken pipe
@@ -147,45 +142,48 @@
         help_message += 'Concatenate FILE(s) to standard output.\n\n'
     for section_id, group in groupby(ALL_ARGS, lambda x: x.section):
         if section_id < 0:
             continue
         relevant_section = False
         for arg in group:
             if arg.show_arg and (not shell or arg.show_arg_on_shell):
-                help_message += f"\t{f'{arg.short_form}, {arg.long_form}': <25}{arg.arg_help}\n"
+                arg_descriptor = f'{arg.short_form}, {arg.long_form}'
+                if len(arg_descriptor) > 35:
+                    arg_descriptor = arg_descriptor[:31] + '...'
+                help_message += f"\t{arg_descriptor: <35}{arg.arg_help}\n"
                 relevant_section = True
         help_message += '\n' * relevant_section
-    help_message += f"\t{'-R, --R<stream>': <25}"
+    help_message += f"\t{'-R, --R<stream>': <35}"
     help_message += 'reconfigure the std-stream(s) with the parsed encoding\n'
     help_message += "\t<stream> == 'in'/'out'/'err' (default is stdin & stdout)\n"
     help_message += '\n'
-    help_message += f"\t{'enc=X, enc:X'    : <25}set file encoding to X (default is utf-8)\n"
-    help_message += f"\t{'find=X, find:X'  : <25}find/query a substring X in the given files\n"
-    help_message += f"\t{'match=X, match:X': <25}find/query a pattern X in the given files\n"
+    help_message += f"\t{'enc=X, enc:X'    : <35}set file encoding to X (default is utf-8)\n"
+    help_message += f"\t{'find=X, find:X'  : <35}find/query a substring X in the given files\n"
+    help_message += f"\t{'match=X, match:X': <35}find/query a pattern X in the given files\n"
     if not shell:
-        help_message += f"\t{'trunc=X:Y, trunc:X:Y': <25}"
+        help_message += f"\t{'trunc=X:Y, trunc:X:Y': <35}"
         help_message += 'truncate file to lines X and Y (python-like)\n'
     help_message += '\n'
-    help_message += f"\t{'[a,b]': <25}replace a with b in every line\n"
-    help_message += f"\t{'[a:b:c]': <25}python-like string indexing syntax (line by line)\n"
+    help_message += f"\t{'[a,b]': <35}replace a with b in every line\n"
+    help_message += f"\t{'[a:b:c]': <35}python-like string indexing syntax (line by line)\n"
     help_message += '\n'
     help_message += 'Examples:\n'
     if shell:
         help_message += '\tcats --ln --dec\n'
         help_message += '\t> >>> 12345\n'
         help_message += '\t1) [53] 12345 {Hexadecimal: 0x3039; Binary: 0b11000000111001}\n'
         help_message += '\t> >>> !help\n'
         help_message += '\t> ...\n'
     else:
-        help_message += f"\t{'catw f g -r' : <25}"
+        help_message += f"\t{'catw f g -r' : <35}"
         help_message += "Output g's contents in reverse order, then f's content in reverse order\n"
-        help_message += f"\t{'catw f g -ne': <25}"
+        help_message += f"\t{'catw f g -ne': <35}"
         help_message += "Output f's, then g's content, "
         help_message += 'while numerating and showing the end of lines\n'
-        help_message += f"\t{'catw f trunc=a:b:c': <25}"
+        help_message += f"\t{'catw f trunc=a:b:c': <35}"
         help_message += "Output f's content starting at line a, ending at line b, stepping c\n"
     try:
         (More(help_message.splitlines())).step_through()
     finally:
         print_update_information(__project__, __version__, color_dic, on_windows_os)
 
 
@@ -215,15 +213,15 @@
     """
     Print all neccassary debug information
     """
     err_print('================================================ '
         'DEBUG ================================================')
     err_print('sys_args:', sys.argv)
     err_print('args: ', end='')
-    err_print([(arg[0], arg[1], holder.args_id[arg[0]]) for arg in args])
+    err_print([(arg[0], arg[1], u_args[arg[0]]) for arg in args])
     err_print('unknown_args: ', end='')
     err_print(unknown_args)
     err_print('known_files: ', end='')
     err_print(known_files)
     err_print('unknown_files: ', end='')
     err_print(unknown_files)
     err_print('echo_args: ', end='')
@@ -231,15 +229,15 @@
     err_print('valid_urls: ', end='')
     err_print(valid_urls)
     err_print('file encoding: ', end='')
     err_print(arg_parser.file_encoding)
     err_print('search keyword(s): ', end='')
     err_print([(v, 'CI' if c else 'CS') for v, c in arg_parser.file_search])
     err_print('search match(es): ', end='')
-    err_print([(v, 'CI' if c else 'CS') for v, c in arg_parser.file_match])
+    err_print(arg_parser.file_match)
     err_print('truncate file: ', end='')
     err_print(arg_parser.file_truncate)
     err_print('replace mapping: ', end='')
     err_print(arg_parser.file_replace_mapping)
     err_print('==================================================='
               '====================================================')
 
@@ -250,15 +248,15 @@
     
     Parameters:
     show_meta (bool):
         decides if the metadata of the files should be displayed
     show_checksum (bool):
         decides if the checksum of the files should be displayed
     """
-    for file in holder.files:
+    for file in u_files:
         if show_meta:
             print_meta(file.path, on_windows_os,
                         [color_dic[CKW.RESET_ALL],
                         color_dic[CKW.ATTRIB],
                         color_dic[CKW.ATTRIB_POSITIVE],
                         color_dic[CKW.ATTRIB_NEGATIVE]])
         if show_checksum:
@@ -306,23 +304,23 @@
         the length of the file number
     
     Returns:
     (str):
         a non-finished but correctly formatted string template to insert line number
         and file index into
     """
-    line_prefix = ' ' * (holder.all_line_number_place_holder - line_char_length)
+    line_prefix = ' ' * (u_files.all_line_number_place_holder - line_char_length)
 
     if file_name_prefix:
         line_prefix = '%i' + line_prefix
     else:
         line_prefix += '%i)'
 
     if include_file_prefix and not file_name_prefix:
-        file_prefix = (' ' * (holder.file_number_place_holder - file_char_length)) + '%i.'
+        file_prefix = (' ' * (u_files.file_number_place_holder - file_char_length)) + '%i.'
         return color_dic[CKW.NUMBER] + file_prefix + line_prefix + color_dic[CKW.RESET_ALL] + ' '
 
     return color_dic[CKW.NUMBER] + line_prefix + color_dic[CKW.RESET_ALL] + ' '
 
 
 def _get_line_prefix(line_num: int, index: int) -> str:
     """
@@ -334,17 +332,17 @@
     index (int):
         the current number identifying the file
     
     Returns:
     (str):
         the new line prefix including the line number.
     """
-    if holder.args_id[ARGS_FILE_PREFIX]:
+    if u_args[ARGS_FILE_PREFIX]:
         return _calculate_line_prefix_spacing(len(str(line_num)), True) % (line_num)
-    if len(holder.files) > 1:
+    if len(u_files) > 1:
         return _calculate_line_prefix_spacing(len(str(line_num)), False, True,
                                               len(str(index))) % (index, line_num)
     return _calculate_line_prefix_spacing(len(str(line_num))) % (line_num)
 
 
 @lru_cache()
 def _calculate_line_length_prefix_spacing(line_char_length: int) -> str:
@@ -355,15 +353,15 @@
     line_char_length (int):
         the length of the line
     
     Returns:
     (str):
         a non-finished but correctly formatted string template to insert line length into
     """
-    length_prefix = '[' + ' ' * (holder.file_line_length_place_holder - line_char_length) + '%i]'
+    length_prefix = '[' + ' ' * (u_files.file_line_length_place_holder - line_char_length) + '%i]'
     return '%s' + color_dic[CKW.LINE_LENGTH] + length_prefix + color_dic[CKW.RESET_ALL] + ' '
 
 
 def _get_line_length_prefix(prefix: str, line) -> str:
     """
     calculates the line prefix in regard to the line length.
     
@@ -373,15 +371,15 @@
     line (str|byte):
         a representation of the current line
     
     Returns:
     (str):
         the new line prefix including the line length.
     """
-    if not holder.args_id[ARGS_NOCOL] and isinstance(line, str):
+    if not u_args[ARGS_NOCOL] and isinstance(line, str):
         line = remove_ansi_codes_from_line(line)
     return _calculate_line_length_prefix_spacing(len(str(len(line)))) % (prefix, len(line))
 
 
 def _get_file_prefix(prefix: str, file_index: int, hyper: bool = False) -> str:
     """
     append the file to the line prefix.
@@ -397,18 +395,18 @@
     
     Returns:
     (str):
         the new line prefix including the file.
     """
     if file_index < 0:
         return prefix
-    file = file_uri_prefix * hyper + holder.files[file_index].displayname
+    file = file_uri_prefix * hyper + u_files[file_index].displayname
     if hyper:
         file = file.replace('\\', '/')
-    if not holder.args_id[ARGS_NUMBER] or hyper:
+    if not u_args[ARGS_NUMBER] or hyper:
         return f"{prefix}{color_dic[CKW.FILE_PREFIX]}{file}{color_dic[CKW.RESET_ALL]} "
     return f"{color_dic[CKW.FILE_PREFIX]}{file}{color_dic[CKW.RESET_ALL]}:{prefix}"
 
 
 def print_file(content: list, stepper: More) -> bool:
     """
     print a file and possibly include the substrings and patterns to search for.
@@ -421,16 +419,16 @@
     (bool):
         identifies if the given content parameter contained any
         queried keyword/pattern.
     """
     if not content:
         return False
     if not any([arg_parser.file_search, arg_parser.file_match,
-                holder.args_id[ARGS_GREP], holder.args_id[ARGS_GREP_ONLY]]):
-        if holder.args_id[ARGS_MORE]:
+                u_args[ARGS_GREP], u_args[ARGS_GREP_ONLY]]):
+        if u_args[ARGS_MORE]:
             stepper.add_lines([prefix + line for prefix, line in content])
             return False
         print(*[prefix + line for prefix, line in content], sep='\n')
         return False
 
     contains_queried = False
     string_finder = StringFinder(arg_parser.file_search,
@@ -440,25 +438,25 @@
         cleaned_line = remove_ansi_codes_from_line(line)
         intervals, f_keywords, m_keywords = string_finder.find_keywords(cleaned_line)
 
         # used for marking the file when displaying applied files
         contains_queried |= bool(intervals)
 
         # this has priority over the other arguments
-        if holder.args_id[ARGS_GREP_ONLY]:
+        if u_args[ARGS_GREP_ONLY]:
             if intervals:
                 fm_substrings = [(pos[0], f"{color_dic[CKW.FOUND]}" + \
                     f"{line[pos[0]:pos[1]]}{color_dic[CKW.RESET_FOUND]}") 
                                  for _, pos in f_keywords]
                 fm_substrings+= [(pos[0], f"{color_dic[CKW.MATCHED]}" + \
                     f"{line[pos[0]:pos[1]]}{color_dic[CKW.RESET_MATCHED]}")
                                  for _, pos in m_keywords]
                 fm_substrings.sort(key=lambda x:x[0])
                 grepped_line = f"{line_prefix}{','.join(sub for _, sub in fm_substrings)}"
-                if holder.args_id[ARGS_MORE]:
+                if u_args[ARGS_MORE]:
                     stepper.add_line(grepped_line)
                     continue
                 print(grepped_line)
             continue
 
         # when bool(intervals) == True -> found keyword or matched pattern!
         # intervals | grep | nokeyword -> print?
@@ -467,55 +465,55 @@
         #     0     |  1   |     0     ->   0
         #     0     |  1   |     1     ->   0
         #     1     |  0   |     0     ->   1
         #     1     |  0   |     1     ->   0
         #     1     |  1   |     0     ->   1
         #     1     |  1   |     1     ->   0
         if not intervals:
-            if not holder.args_id[ARGS_GREP]:
-                if holder.args_id[ARGS_MORE]:
+            if not u_args[ARGS_GREP]:
+                if u_args[ARGS_MORE]:
                     stepper.add_line(line_prefix + line)
                     continue
                 print(line_prefix + line)
             continue
 
-        if holder.args_id[ARGS_NOKEYWORD]:
+        if u_args[ARGS_NOKEYWORD]:
             continue
 
-        if not holder.args_id[ARGS_NOCOL]:
+        if not u_args[ARGS_NOCOL]:
             for kw_pos, kw_code in intervals:
                 cleaned_line = cleaned_line[:kw_pos] + color_dic[kw_code] + cleaned_line[kw_pos:]
 
-        if holder.args_id[ARGS_MORE]:
+        if u_args[ARGS_MORE]:
             stepper.add_line(line_prefix + cleaned_line)
         else:
             print(line_prefix + cleaned_line)
 
-        if holder.args_id[ARGS_GREP] or holder.args_id[ARGS_NOBREAK]:
+        if u_args[ARGS_GREP] or u_args[ARGS_NOBREAK]:
             continue
 
         found_sth = False
         if f_keywords:
             found_message = f"{color_dic[CKW.FOUND_MESSAGE]}--------------- Found "
             found_message+= f"{f_keywords} ---------------{color_dic[CKW.RESET_ALL]}"
-            if holder.args_id[ARGS_MORE]:
+            if u_args[ARGS_MORE]:
                 stepper.add_line(found_message)
             else:
                 print(found_message)
             found_sth = True
         if m_keywords:
             matched_message = f"{color_dic[CKW.MATCHED_MESSAGE]}--------------- Matched "
             matched_message+= f"{m_keywords} ---------------{color_dic[CKW.RESET_ALL]}"
-            if holder.args_id[ARGS_MORE]:
+            if u_args[ARGS_MORE]:
                 stepper.add_line(matched_message)
             else:
                 print(matched_message)
             found_sth = True
 
-        if found_sth and not holder.args_id[ARGS_MORE]:
+        if found_sth and not u_args[ARGS_MORE]:
             try:
                 # fails when using --stdin mode, because the stdin will send en EOF char
                 # to input without prompting the user
                 input()
             except (EOFError, UnicodeDecodeError):
                 pass
 
@@ -549,86 +547,108 @@
     
     Parameters:
     content (list):
         the content of a file like [(prefix, line), ...]
     excluded_by_peek (int):
         the amount of lines that have been originally excluded
     """
-    if not excluded_by_peek or len(content) <= 5:
+    if not excluded_by_peek or len(content) <= const_dic[DKW.PEEK_SIZE]:
         return
-    if any([holder.args_id[ARGS_GREP],
-            holder.args_id[ARGS_GREP_ONLY],
-            holder.args_id[ARGS_NOKEYWORD],
-            holder.args_id[ARGS_MORE]]):
+    if any([u_args[ARGS_GREP],
+            u_args[ARGS_GREP_ONLY],
+            u_args[ARGS_NOKEYWORD],
+            u_args[ARGS_MORE]]):
         return
     _print_excluded_by_peek(len(remove_ansi_codes_from_line(content[0][0])),
-                            excluded_by_peek + 10 - len(content))
+                            excluded_by_peek + 2*const_dic[DKW.PEEK_SIZE] - len(content))
 
 
+def edit_raw_content(content: bytes, file_index: int = 0) -> None:
+    """
+    write raw binary
+
+    Parameters:
+    content (bytes):
+        the raw content of a binary file
+    file_index (int):
+        the index of the u_files.files list, pointing to the file that
+        is currently being processed. a negative value can be used for
+        the shell mode
+    """
+    if u_args[ARGS_STRINGS]:
+        content = get_strings([(b'', content)],
+                              const_dic[DKW.STRINGS_MIN_SEQUENCE_LENGTH],
+                              const_dic[DKW.STRINGS_DELIMETER])
+        return edit_content(content, file_index)
+    if u_args[ARGS_B64E]:
+        content = encode_base64(content)
+    sys.stdout.buffer.write(content)
+
 def edit_content(content: list, file_index: int = 0, line_offset: int = 0) -> None:
     """
     apply all parameters to a string (file Content).
     
     Parameters:
     content (list):
         the content of a file like [(prefix, line), ...]
     file_index (int):
-        the index of the holder.files list, pointing to the file that
+        the index of the u_files.files list, pointing to the file that
         is currently being processed. a negative value can be used for
         the shell mode
     line_offset (int):
         the offset for counting the line numbers (used in the shell)
     """
-    if holder.args_id[ARGS_STRINGS]:
-        content = get_strings(content,
-                              const_dic[DKW.STRINGS_MIN_SEQUENCE_LENGTH],
-                              const_dic[DKW.STRINGS_DELIMETER])
-
-    if holder.args_id[ARGS_SPECIFIC_FORMATS]:
-        content = Formatter.format(content)
-
     if not (content or os.isatty(sys.stdout.fileno()) or file_index < 0):
         # if the content of the file is empty, we check if maybe the file is its own pipe-target.
         # an indicator would be if the file has just been modified to be empty (by the shell).
         # also the stdout cannot be atty.
         # checking if the file is an _unknown_file is not valid, because by using '--stdin'
         # the stdin will be used to write the file
-        file_mtime = get_file_mtime(holder.files[file_index].path)
+        file_mtime = get_file_mtime(u_files[file_index].path)
         date_nowtime = datetime.timestamp(datetime.now())
         if abs(date_nowtime - file_mtime) < 0.5:
             err_print(f"{color_dic[CKW.MESSAGE_WARNING]}Warning: It looks like you are " + \
                 f"trying to pipe a file into itself.{color_dic[CKW.RESET_ALL]}")
             err_print(f"{color_dic[CKW.MESSAGE_WARNING]}In this case you might have lost " + \
                 f"all data.{color_dic[CKW.RESET_ALL]}")
         # in any case we have nothing to do and can return
         return
+
+    if u_args[ARGS_STRINGS]:
+        content = get_strings(content,
+                              const_dic[DKW.STRINGS_MIN_SEQUENCE_LENGTH],
+                              const_dic[DKW.STRINGS_DELIMETER])
+
+    if u_args[ARGS_SPECIFIC_FORMATS]:
+        content = Formatter.format(content)
+
     excluded_by_peek = 0
 
-    if holder.args_id[ARGS_NUMBER]:
+    if u_args[ARGS_NUMBER]:
         content = [(_get_line_prefix(j+line_offset, file_index+1), c[1])
                    for j, c in enumerate(content, start=1)]
     content = content[
         arg_parser.file_truncate[0]:arg_parser.file_truncate[1]:arg_parser.file_truncate[2]
         ]
-    if holder.args_id[ARGS_PEEK] and len(content) > 10:
-        excluded_by_peek = len(content) - 10
-        content = content[:5] + content[-5:]
+    if u_args[ARGS_PEEK] and len(content) > 2*const_dic[DKW.PEEK_SIZE]:
+        excluded_by_peek = len(content) - 2*const_dic[DKW.PEEK_SIZE]
+        content = content[:const_dic[DKW.PEEK_SIZE]] + content[-const_dic[DKW.PEEK_SIZE]:]
 
-    for arg, param in holder.args:
+    for arg, param in u_args:
         if arg == ARGS_CUT:
             slice_evals = [None, None, None]
             for i, p_split in enumerate(param[1:-1].split(':')):
                 try:
                     slice_evals[i] = int(eval(p_split))
                 except (SyntaxError, NameError, ValueError, ArithmeticError):
                     pass
             content = [(prefix, line[slice_evals[0]:slice_evals[1]:slice_evals[2]])
                         for prefix, line in content]
 
-    for arg, param in holder.args:
+    for arg, param in u_args:
         if arg == ARGS_ENDS:
             content = [(prefix, f"{line}{color_dic[CKW.ENDS]}${color_dic[CKW.RESET_ALL]}")
                         for prefix, line in content]
         elif arg == ARGS_SQUEEZE:
             content = [list(group)[0] for _, group in groupby(content, lambda x: x[1])]
         elif arg == ARGS_REVERSE:
             content.reverse()
@@ -656,233 +676,190 @@
             for c_id, char, _, possible in SPECIAL_CHARS:
                 if not possible:
                     continue
                 content = [(prefix, line.replace(
                     chr(c_id), f"{color_dic[CKW.CHARS]}^{char}{color_dic[CKW.RESET_ALL]}"
                     )) for prefix, line in content]
 
-    if holder.args_id[ARGS_LLENGTH]:
+    if u_args[ARGS_LLENGTH]:
         content = [(_get_line_length_prefix(prefix, line), line) for prefix, line in content]
-    if holder.args_id[ARGS_FILE_PREFIX]:
+    if u_args[ARGS_FILE_PREFIX]:
         content = [(_get_file_prefix(prefix, file_index), line) for prefix, line in content]
-    elif holder.args_id[ARGS_FFILE_PREFIX]:
+    elif u_args[ARGS_FFILE_PREFIX]:
         content = [(_get_file_prefix(prefix, file_index, hyper=True), line)
                    for prefix, line in content]
-    if holder.args_id[ARGS_B64E]:
-        content = encode_base64(content, arg_parser.file_encoding)
+    if u_args[ARGS_B64E]:
+        content = encode_base64('\n'.join(''.join(x) for x in content), True,
+                                arg_parser.file_encoding)
+        content = [('', content)]
 
     stepper = More()
     found_queried = print_file(content[:len(content)//2], stepper)
     if file_index >= 0:
-        holder.files[file_index].set_contains_queried(found_queried)
+        u_files[file_index].set_contains_queried(found_queried)
     print_excluded_by_peek(content, excluded_by_peek)
     found_queried = print_file(content[len(content)//2:], stepper)
     if file_index >= 0:
-        holder.files[file_index].set_contains_queried(found_queried)
+        u_files[file_index].set_contains_queried(found_queried)
 
-    if holder.args_id[ARGS_MORE]:
-        stepper.step_through(holder.args_id[ARGS_STDIN])
+    if u_args[ARGS_MORE]:
+        stepper.step_through(u_args[ARGS_STDIN])
 
-    if holder.args_id[ARGS_CLIP]:
-        holder.clip_board += '\n'.join(prefix + line for prefix, line in content)
+    if u_args[ARGS_CLIP]:
+        Clipboard.clipboard += '\n'.join(prefix + line for prefix, line in content)
 
 
 def edit_file(file_index: int = 0) -> None:
     """
     apply all parameters to a file.
     
     Parameters:
     file_index (int):
         the index regarding which file is currently being edited
     """
-    content = [('', '')]
+    if u_args[ARGS_RAW]:
+        raw_content = IoHelper.read_file(u_files[file_index].path, True)
+        edit_raw_content(raw_content, file_index)
+        return
+    content = []
     try:
-        with open(holder.files[file_index].path, 'r', encoding=arg_parser.file_encoding,
-                  errors='strict') as file:
-            # splitlines() gives a slight inaccuracy, in case the last line is empty.
-            # (it also splits on other bytes than \r and \n ...)
-            # the alternative would be worse: split('\n') would increase the linecount each
-            # time catw touches a file.
-            file_content = file.read()
-            if not os.isatty(sys.stdout.fileno()) and const_dic[DKW.STRIP_COLOR_ON_PIPE]:
-                file_content = remove_ansi_codes_from_line(file_content)
-            content = [('', line) for line in file_content.splitlines()]
+        file_content = IoHelper.read_file(u_files[file_index].path, False,
+                                          arg_parser.file_encoding, 'strict')
+        # splitlines() gives a slight inaccuracy, in case the last line is empty.
+        # (it also splits on other bytes than \r and \n ...)
+        # the alternative would be worse: split('\n') would increase the linecount each
+        # time catw touches a file.
+        if not os.isatty(sys.stdout.fileno()) and const_dic[DKW.STRIP_COLOR_ON_PIPE]:
+            file_content = remove_ansi_codes_from_line(file_content)
+        content = [('', line) for line in file_content.splitlines()]
     except PermissionError:
-        err_print(f"Permission denied! Skipping {holder.files[file_index].displayname} ...")
+        err_print(f"Permission denied! Skipping {u_files[file_index].displayname} ...")
         return
     except (BlockingIOError, FileNotFoundError):
         err_print('Resource blocked/unavailable! Skipping ' + \
-            f"{holder.files[file_index].displayname} ...")
+            f"{u_files[file_index].displayname} ...")
         return
     except (OSError, UnicodeError):
-        holder.files[file_index].set_plaintext(plain=False)
-        if holder.args_id[ARGS_PLAIN_ONLY]:
+        u_files[file_index].set_plaintext(plain=False)
+        if u_args[ARGS_PLAIN_ONLY]:
             return
-        if display_zip(holder.files[file_index].path, _convert_size):
+        if display_zip(u_files[file_index].path, _convert_size):
             return
         try:
-            with open(holder.files[file_index].path, 'r', encoding=arg_parser.file_encoding,
-                      errors=('ignore' if const_dic[DKW.IGNORE_UNKNOWN_BYTES] else 'replace')
-                      ) as file:
-                file_content = file.read()
-                if not os.isatty(sys.stdout.fileno()) and const_dic[DKW.STRIP_COLOR_ON_PIPE]:
-                    file_content = remove_ansi_codes_from_line(file_content)
-                content = [('', line) for line in file_content.splitlines()]
+            file_content = IoHelper.read_file(u_files[file_index].path, False,
+                                              arg_parser.file_encoding,
+                                              'ignore' if const_dic[DKW.IGNORE_UNKNOWN_BYTES] else 'replace')
+            if not os.isatty(sys.stdout.fileno()) and const_dic[DKW.STRIP_COLOR_ON_PIPE]:
+                file_content = remove_ansi_codes_from_line(file_content)
+            content = [('', line) for line in file_content.splitlines()]
         except OSError:
             err_print('Operation failed! Try using the enc=X parameter.')
             return
 
     edit_content(content, file_index)
 
 
-def _copy_to_clipboard(content: str, __dependency: int = 3,
-                       __clip_board_error: bool = False) -> object:
-    """
-    copy a string to the clipboard, by recursively checking which module exists and could
-    be used, this function should only be called by copy_to_clipboard()
-    
-    Parameters:
-    content (str):
-        the string to copy
-    __dependency (int):
-        do not change!
-    __clip_board_error (bool):
-        do not change!
-        
-    Returns:
-    (function):
-        the method used for copying to the clipboard
-        (in case we want to use this function again without another import)
-    """
-    if __dependency == 0:
-        if __clip_board_error:
-            error_msg = '\n'
-            error_msg += "ClipBoardError: You can use either 'pyperclip3', "
-            error_msg += "'pyperclip', or 'pyclip' in order to use the '--clip' parameter.\n"
-            error_msg += 'Try to install a different one using '
-            error_msg += f"'{os.path.basename(sys.executable)} -m pip install ...'"
-        else:
-            error_msg = '\n'
-            error_msg += "ImportError: You need either 'pyperclip3', 'pyperclip',"
-            error_msg += "or 'pyclip' in order to use the '--clip' parameter.\n"
-            error_msg += 'Should you have any problem with either module, try to install a diff'
-            error_msg += f"erent one using '{os.path.basename(sys.executable)} -m pip install ...'"
-        err_print(error_msg)
-        return None
-    try:
-        if __dependency == 3:
-            import pyperclip as pc
-        elif __dependency == 2:
-            import pyclip as pc
-        elif __dependency == 1:
-            import pyperclip3 as pc
-        pc.copy(content)
-        return pc.copy
-    except ImportError:
-        return _copy_to_clipboard(content, __dependency-1, False or __clip_board_error)
-    except Exception:
-        return _copy_to_clipboard(content, __dependency-1, True or __clip_board_error)
-
-
-def copy_to_clipboard(content: str, copy_function: object = None) -> object:
-    """
-    entry point to recursive function _copy_to_clipboard()
-    
-    Parameters:
-    content (str):
-        the string to copy
-    copy_function (function):
-        the method to use for copying to the clipboard
-        (in case such a method already exists we do not need to import any module (again))
-        
-    Returns:
-    (function):
-        the method used for copying to the clipboard
-        (in case we want to use this function again without another import)
-    """
-    if copy_function is not None:
-        copy_function(content)
-        return copy_function
-    return _copy_to_clipboard(content)
-
-
 def print_raw_view(file_index: int = 0, mode: str = 'X') -> None:
     """
     print the raw byte representation of a file in hexadecimal or binary
     
     Parameters:
     file_index (int):
         the index regarding which file is currently being edited
     mode (str):
         either 'x', 'X' for hexadecimal (lower- or upper case letters),
         or 'b' for binary
     """
     queue = []
-    skipped = -1
+    skipped = 0
 
-    print(holder.files[file_index].displayname, ':', sep='')
-    raw_gen = get_raw_view_lines_gen(holder.files[file_index].path, mode,
+    print(u_files[file_index].displayname, ':', sep='')
+    raw_gen = get_raw_view_lines_gen(u_files[file_index].path, mode,
                                      [color_dic[CKW.RAWVIEWER], color_dic[CKW.RESET_ALL]],
                                      arg_parser.file_encoding)
     print(next(raw_gen)) # the header will always be available
     for line in raw_gen:
         skipped += 1
-        if holder.args_id[ARGS_PEEK] and skipped > 4:
+        if u_args[ARGS_PEEK] and skipped > const_dic[DKW.PEEK_SIZE]:
             queue.append(line)
-            if len(queue) > 5:
+            if len(queue) > const_dic[DKW.PEEK_SIZE]:
                 queue = queue[1:]
             continue
         print(line)
     if queue:
-        if skipped > 9:
-            _print_excluded_by_peek(21, skipped-9)
+        if skipped > (2*const_dic[DKW.PEEK_SIZE]):
+            _print_excluded_by_peek(21, skipped-2*const_dic[DKW.PEEK_SIZE])
         print('\n'.join(queue))
-    print('')
+    print()
 
 
 def edit_files() -> None:
     """
     manage the calls to edit_file() for each file.
     """
-    start = len(holder.files)-1 if holder.reversed else 0
-    end = -1 if holder.reversed else len(holder.files)
+    start = len(u_files)-1 if u_args[ARGS_REVERSE] else 0
+    end = -1 if u_args[ARGS_REVERSE] else len(u_files)
 
     raw_view_mode = None
-    if holder.args_id[ARGS_HEXVIEW] or holder.args_id[ARGS_BINVIEW]:
-        for arg, param in holder.args:
+    if u_args[ARGS_HEXVIEW] or u_args[ARGS_BINVIEW]:
+        for arg, param in u_args:
             if arg == ARGS_HEXVIEW:
                 raw_view_mode = 'X' if param.isupper() else 'x'
                 break
             if arg == ARGS_BINVIEW:
                 raw_view_mode = 'b'
                 break
 
-    for i in range(start, end, -1 if holder.reversed else 1):
+    for i in range(start, end, -1 if u_args[ARGS_REVERSE] else 1):
         if raw_view_mode:
             print_raw_view(i, raw_view_mode)
         else:
             edit_file(i)
-    if holder.args_id[ARGS_FILES]:
-        print('')
-        Summary.show_files(holder.args_id[ARGS_FFILES], holder.files)
-    if holder.args_id[ARGS_DIRECTORIES]:
-        print('')
+    if u_args[ARGS_FILES]:
+        print()
+        Summary.show_files(u_args[ARGS_FFILES], u_files.files)
+    if u_args[ARGS_DIRECTORIES]:
+        print()
         Summary.show_dirs(arg_parser.get_dirs())
-    if holder.args_id[ARGS_SUM]:
-        print('')
-        Summary.show_sum(holder.args_id[ARGS_SSUM], holder.all_files_lines,
-                         holder.all_line_number_place_holder, holder.all_files_lines_sum)
-    if holder.args_id[ARGS_WORDCOUNT]:
-        print('')
-        Summary.show_wordcount(holder.files, arg_parser.file_encoding)
-    if holder.args_id[ARGS_CHARCOUNT]:
-        print('')
-        Summary.show_charcount(holder.files, arg_parser.file_encoding)
-    if holder.args_id[ARGS_CLIP]:
-        copy_to_clipboard(remove_ansi_codes_from_line(holder.clip_board))
+    if u_args[ARGS_SUM]:
+        print()
+        Summary.show_sum(u_args[ARGS_SSUM], u_files.all_files_lines,
+                         u_files.all_line_number_place_holder, u_files.all_files_lines_sum)
+    if u_args[ARGS_WORDCOUNT]:
+        print()
+        Summary.show_wordcount(u_files.files, arg_parser.file_encoding)
+    if u_args[ARGS_CHARCOUNT]:
+        print()
+        Summary.show_charcount(u_files.files, arg_parser.file_encoding)
+    if u_args[ARGS_CLIP]:
+        Clipboard.put(remove_ansi_codes_from_line(Clipboard.clipboard))
+
+
+def decode_files_base64(tmp_file_helper: TmpFileHelper) -> None:
+    """
+    decode all files from base64 and save to temporary file.
+    
+    Parameters:
+    tmp_file_helper (TmpFileHelper):
+        the TmpFileHelper to keep track of the used tmp files
+    """
+    for i, file in enumerate(u_files):
+        try:
+            tmp_file_path = tmp_file_helper.generate_temp_file_name()
+            f_read_content = IoHelper.read_file(file.path, file_encoding=arg_parser.file_encoding)
+            if u_args[ARGS_RAW]:
+                IoHelper.write_file(tmp_file_path,
+                                    decode_base64(f_read_content))
+            else:
+                IoHelper.write_file(tmp_file_path,
+                                    decode_base64(f_read_content, True, arg_parser.file_encoding),
+                                    arg_parser.file_encoding)
+            u_files[i].path = tmp_file_path
+        except (OSError, UnicodeError):
+            err_print(f"Base64 decoding failed for file: {file.displayname}")
 
 
 def show_unknown_args_suggestions(shell: bool = False) -> list:
     """
     display the unknown arguments passed in aswell as their suggestions
     if possible
     
@@ -909,21 +886,21 @@
     """
     set the color dictionary to be used. either empty for no colors
     or the default color dictionary.
     """
     # do not use colors if requested, or output will be piped anyways
     global color_dic
 
-    if holder.args_id[ARGS_NOCOL] or sys.stdout.closed or \
+    if u_args[ARGS_NOCOL] or sys.stdout.closed or \
         (not os.isatty(sys.stdout.fileno()) and const_dic[DKW.STRIP_COLOR_ON_PIPE]):
         color_dic = dict.fromkeys(color_dic, '')
     else:
         color_dic = default_color_dic.copy()
 
-    converter.set_params(holder.args_id[ARGS_DEBUG],
+    converter.set_params(u_args[ARGS_DEBUG],
                          [color_dic[CKW.EVALUATION],
                           color_dic[CKW.CONVERSION],
                           color_dic[CKW.RESET_ALL]])
 
 
 def init(shell: bool = False) -> tuple:
     """
@@ -940,163 +917,170 @@
         contains (known_files, unknown_files, echo_args, valid_urls) from the argparser
     """
     setup()
 
     # read parameter-args
     args, _, unknown_files, echo_args = arg_parser.get_arguments(sys.argv + config.get_cmd())
 
-    holder.set_args(args)
+    u_args.set_args(args)
 
-    known_files = arg_parser.get_files(holder.args_id[ARGS_DOTFILES])
+    known_files = arg_parser.get_files(u_args[ARGS_DOTFILES])
     valid_urls = []
-    if holder.args_id[ARGS_URI]:
+    if u_args[ARGS_URI]:
         valid_urls, unknown_files = sep_valid_urls(unknown_files)
 
-    if holder.args_id[ARGS_RECONFIGURE] or holder.args_id[ARGS_RECONFIGURE_IN]:
+    if u_args[ARGS_RECONFIGURE] or u_args[ARGS_RECONFIGURE_IN]:
         sys.stdin.reconfigure(encoding=arg_parser.file_encoding)
-    if holder.args_id[ARGS_RECONFIGURE] or holder.args_id[ARGS_RECONFIGURE_OUT]:
+    if u_args[ARGS_RECONFIGURE] or u_args[ARGS_RECONFIGURE_OUT]:
         sys.stdout.reconfigure(encoding=arg_parser.file_encoding)
-    if holder.args_id[ARGS_RECONFIGURE_ERR]:
+    if u_args[ARGS_RECONFIGURE_ERR]:
         sys.stderr.reconfigure(encoding=arg_parser.file_encoding)
 
     init_colors()
 
     arg_suggestions = show_unknown_args_suggestions(shell)
 
     # check for special cases
-    if holder.args_id[ARGS_DEBUG]:
-        _show_debug(holder.args, arg_suggestions, known_files, unknown_files, echo_args, valid_urls)
-    if (len(known_files) + len(unknown_files) + len(holder.args) == 0 and not shell) or \
-        holder.args_id[ARGS_HELP]:
+    if u_args[ARGS_DEBUG]:
+        _show_debug(u_args.args, arg_suggestions, known_files, unknown_files, echo_args, valid_urls)
+    if (len(known_files) + len(unknown_files) + len(u_args) == 0 and not shell) or \
+        u_args[ARGS_HELP]:
         _show_help(shell)
         sys.exit(0)
-    if holder.args_id[ARGS_VERSION]:
+    if u_args[ARGS_VERSION]:
         _show_version()
         sys.exit(0)
-    if holder.args_id[ARGS_CCONFIG]:
-        cconfig.save_config()
+    if u_args[ARGS_CONFIG_REMOVE]:
+        config.remove_config()
+        sys.exit(0)
+    if u_args[ARGS_CONFIG_FLUSH]:
+        config.reset_config()
+        sys.exit(0)
+    if u_args[ARGS_CCONFIG_FLUSH]:
+        cconfig.reset_config()
         sys.exit(0)
-    if holder.args_id[ARGS_CONFIG]:
+    if u_args[ARGS_CONFIG]:
         config.save_config()
         sys.exit(0)
+    if u_args[ARGS_CCONFIG]:
+        cconfig.save_config()
+        sys.exit(0)
 
     Editor.set_indentation(const_dic[DKW.EDITOR_INDENTATION], const_dic[DKW.EDITOR_AUTO_INDENT])
-    Editor.set_flags(holder.args_id[ARGS_STDIN] and on_windows_os,
-                     holder.args_id[ARGS_DEBUG], arg_parser.file_encoding)
+    Editor.set_flags(u_args[ARGS_STDIN] and on_windows_os,
+                     u_args[ARGS_DEBUG], arg_parser.file_encoding)
 
     return (known_files, unknown_files, echo_args, valid_urls)
 
 
 def main():
     """
     main function
     """
+    tmp_file_helper = TmpFileHelper()
     piped_input = temp_file = ''
     known_files, unknown_files, echo_args, valid_urls = init(shell=False)
 
-    if holder.args_id[ARGS_ECHO]:
-        temp_file = stdinhelper.write_file(echo_args, tmp_file_helper.generate_temp_file_name(),
-                                           arg_parser.file_encoding)
+    if u_args[ARGS_ECHO]:
+        temp_file = IoHelper.write_file(tmp_file_helper.generate_temp_file_name(), echo_args,
+                                        arg_parser.file_encoding)
         known_files.append(temp_file)
-        holder.set_temp_file_echo(temp_file)
-    if holder.args_id[ARGS_URI]:
+        u_files.set_temp_file_echo(temp_file)
+    if u_args[ARGS_URI]:
         # the dictionary should contain an entry for each valid_url, since
         # generated temp-files are unique
         temp_files = dict([
-            (stdinhelper.write_file(read_url(valid_url), tmp_file_helper.generate_temp_file_name(),
-                                    arg_parser.file_encoding), valid_url)
+            (IoHelper.write_file(tmp_file_helper.generate_temp_file_name(), read_url(valid_url),
+                                 arg_parser.file_encoding), valid_url)
             for valid_url in valid_urls])
         known_files.extend(list(temp_files.keys()))
-        holder.set_temp_files_url(temp_files)
-    if holder.args_id[ARGS_STDIN]:
-        piped_input = ''.join(stdinhelper.get_stdin_content(holder.args_id[ARGS_ONELINE]))
-        temp_file = stdinhelper.write_file(piped_input, tmp_file_helper.generate_temp_file_name(),
-                                           arg_parser.file_encoding)
+        u_files.set_temp_files_url(temp_files)
+    if u_args[ARGS_STDIN]:
+        piped_input = (b'' if u_args[ARGS_RAW] else '').join(
+            IoHelper.get_stdin_content(
+                u_args[ARGS_ONELINE],
+                u_args[ARGS_RAW]
+                )
+            )
+        temp_file = IoHelper.write_file(tmp_file_helper.generate_temp_file_name(), piped_input,
+                                        arg_parser.file_encoding)
         known_files.append(temp_file)
-        unknown_files = stdinhelper.write_files(unknown_files, piped_input,
+        unknown_files = IoHelper.write_files(unknown_files, piped_input,
                                                 arg_parser.file_encoding)
-        holder.set_temp_file_stdin(temp_file)
-    elif holder.args_id[ARGS_EDITOR]:
+        u_files.set_temp_file_stdin(temp_file)
+    elif u_args[ARGS_EDITOR]:
         unknown_files = [file for file in unknown_files if Editor.open(
-            file, holder.get_file_display_name(file), stdinhelper.write_file,
-            on_windows_os, holder.args_id[ARGS_PLAIN_ONLY])]
+            file, u_files.get_file_display_name(file), IoHelper.write_file,
+            on_windows_os, u_args[ARGS_PLAIN_ONLY])]
     else:
-        unknown_files = stdinhelper.read_write_files_from_stdin(
+        unknown_files = IoHelper.read_write_files_from_stdin(
             unknown_files, arg_parser.file_encoding, on_windows_os,
-            holder.args_id[ARGS_ONELINE])
+            u_args[ARGS_ONELINE])
 
-    if holder.args_id[ARGS_EDITOR]:
-        with stdinhelper.dup_stdin(on_windows_os, holder.args_id[ARGS_STDIN]):
+    if u_args[ARGS_EDITOR]:
+        with IoHelper.dup_stdin(on_windows_os, u_args[ARGS_STDIN]):
             for file in known_files:
-                Editor.open(file, holder.get_file_display_name(file), stdinhelper.write_file,
-                            on_windows_os, holder.args_id[ARGS_PLAIN_ONLY])
+                Editor.open(file, u_files.get_file_display_name(file), IoHelper.write_file,
+                            on_windows_os, u_args[ARGS_PLAIN_ONLY])
 
     if len(known_files) + len(unknown_files) == 0:
         return
 
     # fill holder object with neccessary values
-    holder.set_files([*known_files, *unknown_files])
+    u_files.set_files([*known_files, *unknown_files])
 
-    if holder.args_id[ARGS_FFILES]:
-        Summary.show_files(holder.args_id[ARGS_FFILES], holder.files)
+    if u_args[ARGS_FFILES]:
+        Summary.show_files(u_args[ARGS_FFILES], u_files.files)
         return
-    if holder.args_id[ARGS_DDIRECTORIES]:
+    if u_args[ARGS_DDIRECTORIES]:
         Summary.show_dirs(arg_parser.get_dirs())
         return
-    if holder.args_id[ARGS_DATA] or holder.args_id[ARGS_CHECKSUM]:
-        _print_meta_and_checksum(holder.args_id[ARGS_DATA], holder.args_id[ARGS_CHECKSUM])
+    if u_args[ARGS_DATA] or u_args[ARGS_CHECKSUM]:
+        _print_meta_and_checksum(u_args[ARGS_DATA], u_args[ARGS_CHECKSUM])
         return
 
     file_size_sum = 0
-    for file in holder.files:
+    for file in u_files:
         file.set_file_size(get_file_size(file.path))
         file_size_sum += file.file_size
         if file_size_sum >= const_dic[DKW.LARGE_FILE_SIZE]:
             err_print(color_dic[CKW.MESSAGE_IMPORTANT], end='')
             err_print('An exceedingly large amount of data is being loaded. ', end='')
             err_print('This may require a lot of time and resources.', end='')
             err_print(color_dic[CKW.RESET_ALL])
             break
 
-    if holder.args_id[ARGS_B64D]:
-        for i, file in enumerate(holder.files):
-            try:
-                tmp_file_path = tmp_file_helper.generate_temp_file_name()
-                with open(file.path, 'r', encoding=arg_parser.file_encoding) as f_read:
-                    with open(tmp_file_path, 'w', encoding=arg_parser.file_encoding) as f_write:
-                        f_write.write(_decode_base64(f_read.read())
-                                            .decode(arg_parser.file_encoding, errors='ignore'))
-                holder.files[i].path = tmp_file_path
-            except (OSError, UnicodeError):
-                err_print(f"Base64 decoding failed for file: {file.displayname}")
-    holder.generate_values()
-
-    if holder.args_id[ARGS_SSUM]:
-        Summary.show_sum(holder.args_id[ARGS_SSUM], holder.all_files_lines,
-                         holder.all_line_number_place_holder, holder.all_files_lines_sum)
+    if u_args[ARGS_B64D]:
+        decode_files_base64(tmp_file_helper)
+    u_files.generate_values(u_args[ARGS_SUM] or u_args[ARGS_SSUM] or u_args[ARGS_NUMBER],
+                            u_args[ARGS_LLENGTH])
+
+    if u_args[ARGS_SSUM]:
+        Summary.show_sum(u_args[ARGS_SSUM], u_files.all_files_lines,
+                         u_files.all_line_number_place_holder, u_files.all_files_lines_sum)
         return
-    if holder.args_id[ARGS_WWORDCOUNT]:
-        Summary.show_wordcount(holder.files, arg_parser.file_encoding)
+    if u_args[ARGS_WWORDCOUNT]:
+        Summary.show_wordcount(u_files.files, arg_parser.file_encoding)
         return
-    if holder.args_id[ARGS_CCHARCOUNT]:
-        Summary.show_charcount(holder.files, arg_parser.file_encoding)
+    if u_args[ARGS_CCHARCOUNT]:
+        Summary.show_charcount(u_files.files, arg_parser.file_encoding)
         return
 
     edit_files()  # print the cat-output
 
     # clean-up
-    if holder.args_id[ARGS_DEBUG]:
+    if u_args[ARGS_DEBUG]:
         err_print('================================================ '
             'DEBUG ================================================')
         caches = [
             remove_ansi_codes_from_line,
             _calculate_line_prefix_spacing,
             _calculate_line_length_prefix_spacing,
-            holder.__get_file_lines_sum__,
-            holder.__calc_max_line_length__,
+            u_files._get_file_lines_sum_,
+            u_files._calc_max_line_length_,
             ]
         caches_info = [(cache.__name__,
                         str(cache.cache_info().hits),
                         str(cache.cache_info().misses),
                         str(cache.cache_info().maxsize),
                         str(cache.cache_info().currsize)) for cache in caches]
         max_val = [max(len(_c) for _c in c_info)+1 for c_info in zip(*caches_info)]
@@ -1105,36 +1089,36 @@
             cache_info+= f"hits:{hits.ljust(max_val[1])}"
             cache_info+= f"misses:{misses.ljust(max_val[2])}"
             cache_info+= f"maxsize:{maxsize.ljust(max_val[3])}"
             cache_info+= f"currsize:{currsize.ljust(max_val[4])}"
             cache_info+= f"full:{100*int(currsize)/int(maxsize):6.2f}%"
             err_print(cache_info)
     for tmp_file in tmp_file_helper.get_generated_temp_files():
-        if holder.args_id[ARGS_DEBUG]:
+        if u_args[ARGS_DEBUG]:
             err_print('Cleaning', tmp_file)
         try:
             os.remove(tmp_file)
-        except (FileNotFoundError, PermissionError, OSError) as e:
-            if holder.args_id[ARGS_DEBUG]:
+        except OSError as e:
+            if u_args[ARGS_DEBUG]:
                 err_print(type(e).__name__, tmp_file)
-    if holder.args_id[ARGS_DEBUG]:
+    if u_args[ARGS_DEBUG]:
         err_print('==================================================='
             '====================================================')
 
 
 def shell_main():
     """
     run the shell.
     """
     init(True)
 
     command_prefix = '!'
     shell_prefix = '>>> '
     eof_control_char = 'Z' if on_windows_os else 'D'
-    oneline = holder.args_id[ARGS_ONELINE]
+    oneline = u_args[ARGS_ONELINE]
     shell_session_time_start = monotonic()
 
     class CmdExec:
         """
         handle shell commands.
         """
         def __init__(self) -> None:
@@ -1159,17 +1143,17 @@
                 the line entered in the cat shell
                 
             Returns:
             (bool):
                 indicates if a valid command has been found
                 and executed
             """
-            if cmd[:1] != command_prefix:
+            if not cmd.startswith(command_prefix):
                 return False
-            line_split = cmd[1:].split(' ')
+            line_split = shlex.split(cmd[1:])
             self.last_cmd = line_split[0]
             method = getattr(self, '_command_' + self.last_cmd, self._command_unknown)
             method(line_split[1:])
             return True
 
         def _command_unknown(self, _) -> None:
             print("Command '!", self.last_cmd, "' is unknown.", sep='')
@@ -1190,68 +1174,69 @@
             print(f"Type ^{eof_control_char} (Ctrl + {eof_control_char}) or '!exit' to exit.")
             print("Type '!add <OPTION>', '!del <OPTION>' to add/remove a specific parameter.")
             print("Type '!see', '!clear' to see/remove all active parameters.")
             print("Put a '\\' before a leading '!' to escape the command-input.")
 
         def _command_add(self, cmd: list) -> None:
             arg_parser.gen_arguments([''] + cmd)
-            holder.add_args(arg_parser.get_args())
+            u_args.add_args(arg_parser.get_args())
             show_unknown_args_suggestions(shell=True)
             self.exec_colors()
             _added= [arg for _, arg in arg_parser.get_args()] \
                 if arg_parser.get_args() else 'parameter(s)'
             print(f"successfully added {_added}.")
 
         def _command_del(self, cmd: list) -> None:
             arg_parser.gen_arguments([''] + cmd, True)
-            holder.delete_args(arg_parser.get_args())
+            u_args.delete_args(arg_parser.get_args())
             self.exec_colors()
             _removed = [arg for _, arg in arg_parser.get_args()] \
                 if arg_parser.get_args() else 'parameter(s)'
             print(f"successfully removed {_removed}.")
 
         def _command_clear(self, _) -> None:
             arg_parser.reset_values()
-            self._command_del([arg for _, arg in holder.args])
+            self._command_del([arg for _, arg in u_args])
 
         def _command_see(self, _) -> None:
-            print(f"{'Active Args:': <12} {[arg for _, arg in holder.args]}")
+            print(f"{'Active Args:': <12} {[arg for _, arg in u_args]}")
             if arg_parser.file_search:
                 file_search = [(v, 'CI' if c else 'CS') for v, c in arg_parser.file_search]
                 print(f"{'Literals:':<12} {file_search}")
             if arg_parser.file_match:
-                file_match = [(v, 'CI' if c else 'CS') for v, c in arg_parser.file_match]
-                print(f"{'Matches:': <12} {file_match}")
+                print(f"{'Matches:': <12} {arg_parser.file_match}")
 
         def _command_exit(self, _) -> None:
             self.exit_shell = True
 
 
     cmd = CmdExec()
     command_count = 0
-    copy_function = None
 
     print(__project__, 'v' + __version__, 'shell', '(' + __url__ + ')', end=' - ')
     print("Use 'catw' to handle files.")
     print("Type '!help' for more information.")
 
     print(shell_prefix, end='', flush=True)
-    for i, line in enumerate(stdinhelper.get_stdin_content(oneline)):
+    for i, line in enumerate(IoHelper.get_stdin_content(oneline)):
         stripped_line = line.rstrip('\n')
+        if not os.isatty(sys.stdin.fileno()):
+            print(stripped_line)
         if cmd.exec(stripped_line):
             command_count += 1
             if cmd.exit_shell:
                 break
         else:
+            if u_args[ARGS_B64D]:
+                stripped_line = decode_base64(stripped_line, True, arg_parser.file_encoding)
             stripped_line = stripped_line[:1].replace('\\', '') + stripped_line[1:]
             if stripped_line:
                 edit_content([('', stripped_line)], -1, i-command_count)
-                if holder.args_id[ARGS_CLIP]:
-                    copy_function = copy_to_clipboard(
-                        remove_ansi_codes_from_line(holder.clip_board), copy_function)
-                    holder.clip_board = ''
+                if u_args[ARGS_CLIP]:
+                    Clipboard.put(remove_ansi_codes_from_line(Clipboard.clipboard))
+                    Clipboard.clipboard = ''
         if not oneline:
             print(shell_prefix, end='', flush=True)
 
 
 if __name__ == '__main__':
     main()
```

## Comparing `cat_win/const/argconstants.py` & `cat_win/src/const/argconstants.py`

 * *Files 6% similar despite different names*

```diff
@@ -26,16 +26,17 @@
 ARGS_CHR, ARGS_B64E, ARGS_B64D, ARGS_FFILES, ARGS_GREP = range(25, 30)
 ARGS_NOBREAK, ARGS_ECHO, ARGS_SSUM, ARGS_HEXVIEW, ARGS_BINVIEW = range(30, 35)
 ARGS_NOKEYWORD, ARGS_RECONFIGURE, ARGS_RECONFIGURE_IN = range(35, 38)
 ARGS_RECONFIGURE_OUT, ARGS_RECONFIGURE_ERR = range(38, 40)
 ARGS_EVAL, ARGS_SORT, ARGS_GREP_ONLY, ARGS_PLAIN_ONLY, ARGS_FILE_PREFIX = range(40, 45)
 ARGS_FFILE_PREFIX, ARGS_DOTFILES, ARGS_OCT, ARGS_URI, ARGS_WORDCOUNT = range(45, 50)
 ARGS_WWORDCOUNT, ARGS_DIRECTORIES, ARGS_DDIRECTORIES = range(50, 53)
-ARGS_SPECIFIC_FORMATS, ARGS_CONFIG, ARGS_CHARCOUNT = range(53, 56)
-ARGS_CCHARCOUNT, ARGS_STRINGS, ARGS_MORE = range(56, 59)
+ARGS_SPECIFIC_FORMATS, ARGS_CONFIG = range(53, 55)
+ARGS_CHARCOUNT, ARGS_CCHARCOUNT, ARGS_STRINGS, ARGS_MORE, ARGS_RAW = range(55, 60)
+ARGS_CONFIG_FLUSH, ARGS_CCONFIG_FLUSH, ARGS_CONFIG_REMOVE = range(60, 63)
 
 DIFFERENTIABLE_ARGS = [ARGS_CUT, ARGS_REPLACE]
 
 ALL_ARGS = [
     ArgConstant('-h', '--help', 'show this help message and exit',
 				ARGS_HELP, section=0),
     ArgConstant('-v', '--version', 'output version information and exit',
@@ -149,26 +150,34 @@
 				ARGS_EDITOR, show_arg_on_shell=False, section=10),
     ArgConstant('-c', '--clip', 'copy output to clipboard',
 				ARGS_CLIP, section=10),
     ArgConstant('-M', '--more', 'page through the file step by step',
                 ARGS_MORE, show_arg_on_shell=False, section=10),
 
     # behavioural
+    ArgConstant('-B', '--raw', 'open the file as raw bytes',
+                ARGS_RAW, show_arg_on_shell=False, section=11),
     ArgConstant('--dot', '--dotfiles', 'additionally query and edit dotfiles',
 				ARGS_DOTFILES, show_arg_on_shell=False, section=11),
     ArgConstant('--plain', '--plain-only', 'ignore non-plaintext files automatically',
 				ARGS_PLAIN_ONLY, show_arg_on_shell=False, section=11),
     ArgConstant('--nc', '--nocolor', 'disable colored output',
 				ARGS_NOCOL, section=11),
 
     # configuration
     ArgConstant('--config', '--config', 'change default parameters',
 				ARGS_CONFIG, section=12),
     ArgConstant('--cconfig', '--cconfig', 'change color configuration',
 				ARGS_CCONFIG, section=12),
+    ArgConstant('--config-clear', '--config-reset', 'reset the config to default settings',
+				ARGS_CONFIG_FLUSH, section=12),
+    ArgConstant('--cconfig-clear', '--cconfig-reset', 'reset the color config to default settings',
+				ARGS_CCONFIG_FLUSH, section=12),
+    ArgConstant('--config-remove', '--cconfig-remove', 'remove the config-file',
+				ARGS_CONFIG_REMOVE, section=12),
 
     # streams
     ArgConstant('-R', '--R', 'reconfigure the stdin and stdout with the parsed encoding',
 				ARGS_RECONFIGURE, show_arg=False),
     ArgConstant('--Rin', '--Rin', 'reconfigure the stdin with the parsed encoding',
 				ARGS_RECONFIGURE_IN, show_arg=False),
     ArgConstant('--Rout', '--Rout', 'reconfigure the stdout with the parsed encoding',
```

## Comparing `cat_win/const/colorconstants.py` & `cat_win/src/const/colorconstants.py`

 * *Files identical despite different names*

## Comparing `cat_win/const/defaultconstants.py` & `cat_win/src/const/defaultconstants.py`

 * *Files 22% similar despite different names*

```diff
@@ -8,14 +8,15 @@
     The collection of all default constants
     """
     DEFAULT_COMMAND_LINE = 'default_command_line'
     DEFAULT_FILE_ENCODING = 'default_file_encoding'
     LARGE_FILE_SIZE = 'large_file_size'
     STRIP_COLOR_ON_PIPE = 'strip_color_on_pipe'
     IGNORE_UNKNOWN_BYTES = 'ignore_unknown_bytes'
+    PEEK_SIZE = 'peek_size'
     EDITOR_INDENTATION = 'editor_indentation'
     EDITOR_AUTO_INDENT = 'editor_auto_indent'
     STRINGS_MIN_SEQUENCE_LENGTH = 'strings_minimum_sequence_length'
     STRINGS_DELIMETER = 'strings_delimeter'
     UNICODE_ESCAPED_FIND = 'unicode_escaped_find'
     UNICODE_ESCAPED_REPLACE = 'unicode_escaped_replace'
     MORE_STEP_LENGTH = 'more_step_length'
```

## Comparing `cat_win/persistence/cconfig.py` & `cat_win/src/persistence/cconfig.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 """
 cconfig
 """
 
 import configparser
 import os
-import sys
 
-from cat_win.const.colorconstants import ColorOptions, CKW
+from cat_win.src.const.colorconstants import ColorOptions, CKW
+from cat_win.src.service.helper.iohelper import err_print
 
 
 class CConfig:
     """
     manages the color configuration. Displays the user interface,
     allows for reading and writing the config file.
     """
@@ -66,26 +66,26 @@
         Returns:
         color_dic (dict):
             a dictionary translating from CKW-keywords to ANSI-Colorcodes
         On Error: Return the default color config
         """
         try:
             self.config_parser.read(self.config_file, encoding='utf-8')
-            config_colors = self.config_parser['COLORS']
+            config_colors = dict(self.config_parser.items('COLORS'))
             for element in self.elements:
                 try:
                     color_type, color = config_colors[element].split('.')
                     self.color_dic[element] = (
                         ColorOptions.Fore[color] if color_type == 'Fore'
                         else ColorOptions.Back[color]
                         )
                 except KeyError:
                     self.color_dic[element] = self.default_dic[element]
-        except KeyError:
-            self.config_parser['COLORS'] = {}
+        except configparser.NoSectionError:
+            self.config_parser.add_section('COLORS')
             # If an error occures we simply use the default colors
             self.color_dic = self.default_dic.copy()
 
         # The Reset Codes should always be the same
         self.color_dic[CKW.RESET_ALL] = ColorOptions.Style['RESET']
         self.color_dic[CKW.RESET_FOUND] = ColorOptions.Fore['RESET']
         self.color_dic[CKW.RESET_MATCHED] = ColorOptions.Back['RESET']
@@ -184,62 +184,83 @@
                 config_menu += f"{element: <{element_offset}}"
                 config_menu += f"{ColorOptions.Style['RESET']} "
             if index % columns == columns-1:
                 config_menu += '\n'
 
         print(config_menu)
 
+    def _save_config(self, keyword: str, value: str = ''):
+        """
+        write the value to the config-file
+        
+        Parameters:
+        keyword (str):
+            the keyword in self.elements
+        value (str):
+            the value to write
+        """
+        if keyword is not None:
+            self.config_parser.set('COLORS', keyword, f'"{value}"')
+        try:
+            with open(self.config_file, 'w', encoding='utf-8') as conf:
+                self.config_parser.write(conf)
+            print(f"Successfully updated config file:\n\t{self.config_file}")
+        except OSError:
+            err_print(f"Could not write to config file:\n\t{self.config_file}")
+
     def save_config(self) -> None:
         """
         Guide the User through the configuration options and save the changes.
         Assume, that the current config is already loaded/
         the method load_config() was already called.
         """
         self._print_all_available_elements()
         keyword = ''
         while keyword not in self.elements:
             if keyword != '':
                 print(f"Something went wrong. Unknown keyword '{keyword}'")
             try:
                 keyword = input('Input name or id of the element to change: ')
             except EOFError:
-                print('\nAborting due to End-of-File character...', file=sys.stderr)
+                err_print('\nAborting due to End-of-File character...')
                 return
             if keyword.isdigit():
                 keyword = self.elements[int(keyword)-1] if (
                     0 < int(keyword) <= len(self.elements)) else keyword
         print('Successfully selected element ', end='')
-        print(f"'{self.color_dic[keyword]}{keyword}{ColorOptions.Style['RESET']}'.")
+        print(f"'{self.color_dic[keyword]}{keyword}{ColorOptions.Style['RESET']}'", end=' ')
+        print(f"[Default: '{self.default_dic[keyword]}{keyword}{ColorOptions.Style['RESET']}']")
 
         color_options = self._print_get_all_available_colors()
         color = ''
         while color not in color_options:
             if color != '':
                 print(f"Something went wrong. Unknown option '{color}'.")
             try:
                 color = input('Input new color: ')
             except EOFError:
-                print('\nAborting due to End-of-File character...', file=sys.stderr)
+                err_print('\nAborting due to End-of-File character...')
                 return
             if color.isdigit():
                 color = color_options[int(color)-1] if (
                     0 < int(color) <= len(color_options)) else color
 
         if keyword in self.exclusive_definitions['Fore'] and color.startswith('Back'):
-            print(f"An Error occured: '{keyword}' can only be of style 'Fore'", file=sys.stderr)
+            err_print(f"An Error occured: '{keyword}' can only be of style 'Fore'")
             return
         if keyword in self.exclusive_definitions['Back'] and color.startswith('Fore'):
-            print(f"An Error occured: '{keyword}' can only be of style 'Back'", file=sys.stderr)
+            err_print(f"An Error occured: '{keyword}' can only be of style 'Back'")
             return
 
         color_split = color.split('.')
         print('Successfully selected element ', end='')
         print(f"'{getattr(ColorOptions, color_split[0])[color_split[1]]}", end='')
         print(f"{color}{ColorOptions.Style['RESET']}'.")
 
-        self.config_parser['COLORS'][keyword] = color
-        try:
-            with open(self.config_file, 'w', encoding='utf-8') as conf:
-                self.config_parser.write(conf)
-            print(f"Successfully updated config file:\n\t{self.config_file}")
-        except OSError:
-            print(f"Could not write to config file:\n\t{self.config_file}", file=sys.stderr)
+        self._save_config(keyword, color)
+
+    def reset_config(self) -> None:
+        """
+        reset the cconfig to default by simply deleting the config section.
+        """
+        self.config_parser.remove_section('COLORS')
+        self._save_config(None)
```

## Comparing `cat_win/persistence/config.py` & `cat_win/src/persistence/config.py`

 * *Files 15% similar despite different names*

```diff
@@ -4,43 +4,50 @@
 
 import codecs
 import configparser
 import os
 import shlex
 import sys
 
-from cat_win.const.defaultconstants import DKW
+from cat_win.src.const.defaultconstants import DKW
+from cat_win.src.service.helper.iohelper import err_print
 
 
 BOOL_POS_RESPONSE = ['TRUE','YES','Y','1']
 BOOL_NEG_RESPONSE = ['FALSE','NO','N','0']
 BOOL_RESPONSE = BOOL_POS_RESPONSE + BOOL_NEG_RESPONSE
 
 
 def validator_string(_, d_h: bool=False):
     if d_h:
-        print('Any UTF-8 String (unicode-escaped)', file=sys.stderr)
+        err_print('Any UTF-8 String (unicode-escaped)')
         return False
     return True
 
 def validator_int(value: str, d_h: bool=False):
     if d_h:
-        print('Integers greater than Zero', file=sys.stderr)
+        err_print('Integers greater than Zero or Zero')
         return False
     return value.isdigit() and int(value) >= 0
 
+def validator_int_pos(value: str, d_h: bool=False):
+    if d_h:
+        err_print('Integers greater than Zero')
+        return False
+    return value.isdigit() and int(value) > 0
+
 def validator_bool(value: str, d_h: bool=False):
     if d_h:
-        print(BOOL_RESPONSE, '(not case sensitive)', file=sys.stderr)
+        err_print(BOOL_RESPONSE, '(not case sensitive)')
         return False
     return value.upper() in BOOL_RESPONSE
 
 def validator_encoding(value: str, d_h: bool=False):
     if d_h:
-        print('Valid Encoding Formats defined by the current Python Interpreter', file=sys.stderr)
+        err_print('Valid Encoding Formats defined by the current Python Interpreter')
         return False
     try:
         return codecs.lookup(value) is not None
     except LookupError:
         return False
 
 
@@ -51,14 +58,15 @@
     """
     default_dic = {
         DKW.DEFAULT_COMMAND_LINE: '',
         DKW.DEFAULT_FILE_ENCODING: 'utf-8',
         DKW.LARGE_FILE_SIZE: 1024 * 1024 * 100,  # 100 Megabytes
         DKW.STRIP_COLOR_ON_PIPE: True,
         DKW.IGNORE_UNKNOWN_BYTES: False,
+        DKW.PEEK_SIZE: 5,
         DKW.EDITOR_INDENTATION: '\t',
         DKW.EDITOR_AUTO_INDENT: False,
         DKW.STRINGS_MIN_SEQUENCE_LENGTH: 4,
         DKW.STRINGS_DELIMETER: '\n',
         DKW.UNICODE_ESCAPED_FIND: True,
         DKW.UNICODE_ESCAPED_REPLACE: True,
         DKW.MORE_STEP_LENGTH: 0,
@@ -66,17 +74,18 @@
 
     v_validation = {
         DKW.DEFAULT_COMMAND_LINE: validator_string,
         DKW.DEFAULT_FILE_ENCODING: validator_encoding,
         DKW.LARGE_FILE_SIZE: validator_int,
         DKW.STRIP_COLOR_ON_PIPE: validator_bool,
         DKW.IGNORE_UNKNOWN_BYTES: validator_bool,
+        DKW.PEEK_SIZE: validator_int_pos,
         DKW.EDITOR_INDENTATION: validator_string,
         DKW.EDITOR_AUTO_INDENT: validator_bool,
-        DKW.STRINGS_MIN_SEQUENCE_LENGTH: validator_int,
+        DKW.STRINGS_MIN_SEQUENCE_LENGTH: validator_int_pos,
         DKW.STRINGS_DELIMETER: validator_string,
         DKW.UNICODE_ESCAPED_FIND: validator_bool,
         DKW.UNICODE_ESCAPED_REPLACE: validator_bool,
         DKW.MORE_STEP_LENGTH: validator_int,
     }
 
     elements = list(default_dic.keys())
@@ -108,16 +117,16 @@
         (element_type):
             whatever the element got converted to
         """
         def fix_invalid_value(value: str, element: str):
             c_value_rep = repr(self.default_dic[element])
             if c_value_rep[0] not in ['"', "'"]:
                 c_value_rep = f"'{c_value_rep}'"
-            print(f"invalid config value '{value}' for '{element}'", file=sys.stderr)
-            print(f"resetting to {c_value_rep} ...", file=sys.stderr)
+            err_print(f"invalid config value '{value}' for '{element}'")
+            err_print(f"resetting to {c_value_rep} ...")
             self._save_config(element, self.default_dic[element])
             sys.exit(1)
 
         value = value[1:-1] # strip the quotes
 
         # check validity and possibly reset to default:
         if not self.v_validation[element](value):
@@ -171,24 +180,24 @@
         Returns:
         const_dic (dict):
             a dictionary translating from DKW-keywords to values
         On Error: Return the default const config
         """
         try:
             self.config_parser.read(self.config_file, encoding='utf-8')
-            config_consts = self.config_parser['CONSTS']
+            config_consts = dict(self.config_parser.items('CONSTS'))
             for element in self.elements:
                 try:
                     self.const_dic[element] = self.convert_config_element(
                         config_consts[element],
                         element)
                 except KeyError:
                     self.const_dic[element] = self.default_dic[element]
-        except KeyError:
-            self.config_parser['CONSTS'] = {}
+        except configparser.NoSectionError:
+            self.config_parser.add_section('CONSTS')
             # If an error occures we simply use the default colors
             self.const_dic = self.default_dic.copy()
 
         return self.const_dic
 
     def _print_all_available_elements(self) -> None:
         """
@@ -212,64 +221,90 @@
             config_menu += f"{index+1: <{index_offset}}: "
             config_menu += f"{element: <{element_offset}}"
             if index % columns == columns-1:
                 config_menu += '\n'
 
         print(config_menu)
 
-    def _save_config(self, keyword: str, value: str):
+    def _save_config(self, keyword: str, value: str = ''):
         """
         write the value to the config-file
         
         Parameters:
         keyword (str):
             the keyword in self.elements
         value (str):
             the value to write
         """
-        self.config_parser['CONSTS'][keyword] = f'"{value}"'
+        if keyword is not None:
+            self.config_parser.set('CONSTS', keyword, f'"{value}"')
         try:
             with open(self.config_file, 'w', encoding='utf-8') as conf:
                 self.config_parser.write(conf)
             print(f"Successfully updated config file:\n\t{self.config_file}")
         except OSError:
-            print(f"Could not write to config file:\n\t{self.config_file}", file=sys.stderr)
+            err_print(f"Could not write to config file:\n\t{self.config_file}")
 
 
     def save_config(self) -> None:
         """
         Guide the User through the configuration options and save the changes.
         Assume, that the current config is already loaded/
         the method load_config() was already called.
         """
         self._print_all_available_elements()
         keyword = ''
         while keyword not in self.elements:
             if keyword != '':
-                print(f"Something went wrong. Unknown keyword '{keyword}'", file=sys.stderr)
+                err_print(f"Something went wrong. Unknown keyword '{keyword}'")
             try:
                 keyword = input('Input name or id of keyword to change: ')
             except EOFError:
-                print('\nAborting due to End-of-File character...', file=sys.stderr)
+                err_print('\nAborting due to End-of-File character...')
                 return
             if keyword.isdigit():
                 keyword = self.elements[int(keyword)-1] if (
                     0 < int(keyword) <= len(self.elements)) else keyword
         print(f"Successfully selected element '{keyword}'")
         c_value_rep = repr(self.const_dic[keyword])
         if c_value_rep[0] not in ['"', "'"]:
             c_value_rep = f"'{c_value_rep}'"
-        print(f"The current value of '{keyword}' is {c_value_rep}")
+        d_value_rep = repr(self.default_dic[keyword])
+        if d_value_rep[0] not in ['"', "'"]:
+            d_value_rep = f"'{d_value_rep}'"
+        print(f"The current value of '{keyword}' is {c_value_rep}", end=' ')
+        print(f"[Default: {d_value_rep}]")
 
         value = None
         while not self.is_valid_value(value, keyword):
             if value is not None:
-                print(f"Something went wrong. Invalid option: '{value}'.", file=sys.stderr)
-                print('Valid Options are: ', end='', file=sys.stderr)
+                err_print(f"Something went wrong. Invalid option: '{value}'.")
+                err_print('Valid Options are: ', end='')
                 self.v_validation[keyword](None, True)
             try:
                 value = input('Input new value: ')
             except EOFError:
-                print('\nAborting due to End-of-File character...', file=sys.stderr)
+                err_print('\nAborting due to End-of-File character...')
                 return
 
         self._save_config(keyword, value)
+
+    def reset_config(self) -> None:
+        """
+        reset the config to default by simply deleting the config section.
+        """
+        self.config_parser.remove_section('CONSTS')
+        self._save_config(None)
+
+    def remove_config(self) -> None:
+        """
+        remove the config file.
+        """
+        try:
+            os.remove(self.config_file)
+            print('The config file has successfully been removed!')
+        except FileNotFoundError:
+            err_print('No active config file has been found.')
+        except PermissionError:
+            err_print('Permission denied! The config file could not be deleted.')
+        except OSError:
+            err_print('An unexpected error occured.')
```

## Comparing `cat_win/tests/test_ansi.py` & `cat_win/tests/src/test_ansi.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,103 +1,103 @@
 from unittest import TestCase
 from unittest.mock import patch
 import os
 
-from cat_win import cat
-from cat_win.const.defaultconstants import DKW
+from cat_win.src import cat
+from cat_win.src.const.defaultconstants import DKW
 from cat_win.tests.mocks.std import StdOutMock, OSAttyDefGen
-from cat_win.persistence.cconfig import CConfig
-from cat_win.persistence.config import Config
+from cat_win.src.persistence.cconfig import CConfig
+from cat_win.src.persistence.config import Config
 # import sys
 # sys.path.append('../cat_win')
 
 
-ansi_pos_file_path = os.path.join(os.path.dirname(__file__), 'texts', 'ansi-pos.txt')
-ansi_neg_file_path = os.path.join(os.path.dirname(__file__), 'texts', 'ansi-neg.txt')
-ansi_base_file_path = os.path.join(os.path.dirname(__file__), 'texts', 'ansi-base.txt')
+ansi_pos_file_path = os.path.join(os.path.dirname(__file__),  '..', 'texts', 'ansi-pos.txt')
+ansi_neg_file_path = os.path.join(os.path.dirname(__file__),  '..', 'texts', 'ansi-neg.txt')
+ansi_base_file_path = os.path.join(os.path.dirname(__file__), '..', 'texts', 'ansi-base.txt')
 ansi_pos_file_content = ''
 ansi_neg_file_content = ''
 with open(ansi_pos_file_path, 'r', encoding='utf-8') as f:
     ansi_pos_file_content = f.read()
 with open(ansi_neg_file_path, 'r', encoding='utf-8') as f:
     ansi_neg_file_content = f.read()
 
 
 load_strip_color_dic_true = lambda: Config.default_dic.copy()
 strip_color_dic_false = Config.default_dic.copy()
 strip_color_dic_false[DKW.STRIP_COLOR_ON_PIPE] = False
 load_strip_color_dic_false = lambda: strip_color_dic_false
 
 
-@patch('cat_win.cat.cconfig.load_config', lambda: CConfig.default_dic.copy())
+@patch('cat_win.src.cat.cconfig.load_config', lambda: CConfig.default_dic.copy())
 @patch('os.isatty', OSAttyDefGen.get_def({1: False}))
 class TestAnsiPiped(TestCase):
     maxDiff = None
 
     def tearDown(self):
         cat._calculate_line_prefix_spacing.cache_clear()
         cat._calculate_line_length_prefix_spacing.cache_clear()
 
     @patch('sys.argv', ['<CAT>', ansi_pos_file_path])
-    @patch('cat_win.cat.config.load_config', load_strip_color_dic_true)
+    @patch('cat_win.src.cat.config.load_config', load_strip_color_dic_true)
     def test_cat_ansi_input_strip(self):
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.main()
             self.assertEqual(fake_out.getvalue(), ansi_neg_file_content)
 
     @patch('sys.argv', ['<CAT>', ansi_pos_file_path])
-    @patch('cat_win.cat.config.load_config', load_strip_color_dic_false)
+    @patch('cat_win.src.cat.config.load_config', load_strip_color_dic_false)
     def test_cat_ansi_input_no_strip(self):
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.main()
             self.assertEqual(fake_out.getvalue(), ansi_pos_file_content)
 
     @patch('sys.argv', ['<CAT>', ansi_base_file_path, '-ln'])
-    @patch('cat_win.cat.config.load_config', load_strip_color_dic_true)
+    @patch('cat_win.src.cat.config.load_config', load_strip_color_dic_true)
     def test_cat_ansi_strip(self):
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.main()
             self.assertEqual(fake_out.getvalue(), ansi_neg_file_content)
 
     @patch('sys.argv', ['<CAT>', ansi_base_file_path, '-ln'])
-    @patch('cat_win.cat.config.load_config', load_strip_color_dic_false)
+    @patch('cat_win.src.cat.config.load_config', load_strip_color_dic_false)
     def test_cat_ansi_no_strip(self):
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.main()
             self.assertEqual(fake_out.getvalue(), ansi_pos_file_content)
 
-@patch('cat_win.cat.cconfig.load_config', lambda: CConfig.default_dic.copy())
+@patch('cat_win.src.cat.cconfig.load_config', lambda: CConfig.default_dic.copy())
 @patch('os.isatty', OSAttyDefGen.get_def({1: True}))
 class TestAnsiNotPiped(TestCase):
     maxDiff = None
 
     def tearDown(self):
         cat._calculate_line_prefix_spacing.cache_clear()
         cat._calculate_line_length_prefix_spacing.cache_clear()
 
     @patch('sys.argv', ['<CAT>', ansi_pos_file_path])
-    @patch('cat_win.cat.config.load_config', load_strip_color_dic_true)
+    @patch('cat_win.src.cat.config.load_config', load_strip_color_dic_true)
     def test_cat_ansi_input_strip(self):
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.main()
             self.assertEqual(fake_out.getvalue(), ansi_pos_file_content)
 
     @patch('sys.argv', ['<CAT>', ansi_pos_file_path])
-    @patch('cat_win.cat.config.load_config', load_strip_color_dic_false)
+    @patch('cat_win.src.cat.config.load_config', load_strip_color_dic_false)
     def test_cat_ansi_input_no_strip(self):
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.main()
             self.assertEqual(fake_out.getvalue(), ansi_pos_file_content)
 
     @patch('sys.argv', ['<CAT>', ansi_base_file_path, '-ln'])
-    @patch('cat_win.cat.config.load_config', load_strip_color_dic_true)
+    @patch('cat_win.src.cat.config.load_config', load_strip_color_dic_true)
     def test_cat_ansi_strip(self):
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.main()
             self.assertEqual(fake_out.getvalue(), ansi_pos_file_content)
 
     @patch('sys.argv', ['<CAT>', ansi_base_file_path, '-ln'])
-    @patch('cat_win.cat.config.load_config', load_strip_color_dic_false)
+    @patch('cat_win.src.cat.config.load_config', load_strip_color_dic_false)
     def test_cat_ansi_no_strip(self):
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.main()
             self.assertEqual(fake_out.getvalue(), ansi_pos_file_content)
```

## Comparing `cat_win/tests/test_argconstants.py` & `cat_win/tests/src/const/test_argconstants.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from unittest import TestCase
 
-from cat_win.const.argconstants import ALL_ARGS
+from cat_win.src.const.argconstants import ALL_ARGS
 # import sys
 # sys.path.append('../cat_win')
 
 
 class TestArgConstants(TestCase):
     def test_unique_parameters(self):
         parameters_short_form = [x.short_form for x in ALL_ARGS]
```

## Comparing `cat_win/tests/test_argparser.py` & `cat_win/tests/src/test_argparser.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 from unittest import TestCase
 import os
 
-from cat_win.const.argconstants import ARGS_CUT, ARGS_REPLACE
-from cat_win.util.argparser import ArgParser, levenshtein
+from cat_win.src.const.argconstants import ARGS_CUT, ARGS_REPLACE
+from cat_win.src.argparser import ArgParser, levenshtein
 # import sys
 # sys.path.append('../cat_win')
 
-test_file_dir = os.path.dirname(__file__)
-project_dir = os.path.dirname(test_file_dir)
+test_file_dir = os.path.join(os.path.dirname(__file__), '..')
+project_dir = os.path.join(test_file_dir, '..')
 test_text_file_dir = os.path.join(test_file_dir, 'texts')
 
 
 class TestArgParser(TestCase):
     maxDiff = None
 
     def test_get_arguments_empty(self):
@@ -77,17 +77,17 @@
         self.assertEqual(arg_parser.file_encoding, 'ascii')
         arg_parser.get_arguments(['CAT', 'enc=utf-8'])
         self.assertEqual(arg_parser.file_encoding, 'utf-8')
 
     def test_get_arguments_match(self):
         arg_parser = ArgParser()
         arg_parser.get_arguments(['CAT', 'match:\\Atest\\Z'])
-        self.assertCountEqual(arg_parser.file_match, set([('\\Atest\\Z', False)]))
+        self.assertCountEqual([p.pattern for p in arg_parser.file_match], ['\\Atest\\Z'])
         arg_parser.get_arguments(['CAT', 'match=\\Atest\\Z'])
-        self.assertCountEqual(arg_parser.file_match, set([('\\Atest\\Z', False)]))
+        self.assertCountEqual([p.pattern for p in arg_parser.file_match], ['\\Atest\\Z'])
 
     def test_get_arguments_find(self):
         arg_parser = ArgParser()
         arg_parser.get_arguments(['CAT', 'find=Test123'])
         self.assertCountEqual(arg_parser.file_search, set([('Test123', False)]))
         arg_parser.get_arguments(['CAT', 'FIND:Test123'])
         self.assertCountEqual(arg_parser.file_search, set([('Test123', False), ('Test123', True)]))
@@ -202,17 +202,19 @@
         arg_parser._add_argument('find=world')
         self.assertSetEqual(arg_parser.file_search, set([('hello', False), ('world', False)]))
         arg_parser._add_argument('find=hello', True)
         self.assertSetEqual(arg_parser.file_search, set([('world', False)]))
 
         arg_parser._add_argument('match=[a-z]')
         arg_parser._add_argument('match=[0-9]')
-        self.assertSetEqual(arg_parser.file_match, set([('[a-z]', False), ('[0-9]', False)]))
+        self.assertEqual(len(arg_parser.file_match), 2)
+        self.assertCountEqual([p.pattern for p in arg_parser.file_match], ['[a-z]', '[0-9]'])
         arg_parser._add_argument('match=[0-9]', True)
-        self.assertSetEqual(arg_parser.file_match, set([('[a-z]', False)]))
+        self.assertEqual(len(arg_parser.file_match), 1)
+        self.assertCountEqual([p.pattern for p in arg_parser.file_match], ['[a-z]'])
 
     def test_check_unknown_args(self):
         arg_parser = ArgParser()
         arg_parser._add_argument('--number')
         arg_parser._add_argument('--sord')
         arg_parser._add_argument('--b64')
         arg_parser._add_argument('--blq4k')
@@ -236,38 +238,37 @@
         self.assertAlmostEqual(levenshtein('The dog sat on the cat', 'The cat sat on the mat'),
                                81.8181, 3)
         self.assertAlmostEqual(levenshtein('lower!', 'LOWER?'), 83.3333, 3)
         self.assertAlmostEqual(levenshtein('--hecksview', '--hexview'), 66.6666, 3)
 
     def test_known_directories(self):
         inside_project_dirs = [
-            'const',
-            'persistence',
+            'src',
             'tests',
-            'util',
-            'web',
         ]
         inside_test_dirs = [
             'mocks',
             'resources',
+            'src',
             'texts',
         ]
+
         arg_parser = ArgParser()
         arg_parser._add_argument(test_file_dir)
         arg_parser.get_files()
-        dirs = '\n'.join(arg_parser.get_dirs())
-        for dir in inside_test_dirs:
-            self.assertIn(dir, dirs)
+        dirs = '\n'.join(map(os.path.basename, arg_parser.get_dirs()))
+        for _dir in inside_test_dirs:
+            self.assertIn(_dir, dirs)
 
         arg_parser = ArgParser()
         arg_parser._add_argument(project_dir)
         arg_parser.get_files()
-        dirs = '\n'.join(arg_parser.get_dirs())
-        for dir in inside_project_dirs:
-            self.assertIn(dir, dirs)
+        dirs = '\n'.join(map(os.path.basename, arg_parser.get_dirs()))
+        for _dir in inside_project_dirs:
+            self.assertIn(_dir, dirs)
 
         arg_parser = ArgParser()
         arg_parser._add_argument(project_dir + '/**/')
         arg_parser.get_files()
-        dirs = '\n'.join(arg_parser.get_dirs())
-        for dir in inside_project_dirs + inside_test_dirs:
-            self.assertIn(dir, dirs)
+        dirs = '\n'.join(map(os.path.basename, arg_parser.get_dirs()))
+        for _dir in inside_project_dirs + inside_test_dirs:
+            self.assertIn(_dir, dirs)
```

## Comparing `cat_win/tests/test_cat.py` & `cat_win/tests/src/test_cat.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,33 +1,33 @@
 from unittest import TestCase
 from unittest.mock import patch
 import os
 
-from cat_win import cat
-from cat_win.const.argconstants import ARGS_ENDS, ARGS_REVERSE, ARGS_CHR
+from cat_win.src import cat
+from cat_win.src.const.argconstants import ARGS_ENDS, ARGS_REVERSE, ARGS_CHR
 from cat_win.tests.mocks.std import StdOutMock, StdInMock
-from cat_win.util.helper.file import File
-from cat_win.persistence.cconfig import CConfig
-from cat_win.persistence.config import Config
+from cat_win.src.domain.file import File
+from cat_win.src.persistence.cconfig import CConfig
+from cat_win.src.persistence.config import Config
 # import sys
 # sys.path.append('../cat_win')
 
 
-test_file_path = os.path.join(os.path.dirname(__file__), 'texts', 'test.txt')
+test_file_path = os.path.join(os.path.dirname(__file__), '..', 'texts', 'test.txt')
 test_file_content = []
 with open(test_file_path, 'r', encoding='utf-8') as f:
     test_file_content = f.read().split('\n')
 
 
 @patch('os.get_terminal_size', lambda: (120, 30))
 class TestCat(TestCase):
     maxDiff = None
 
-    @patch('cat_win.cat.cconfig.load_config', lambda: dict.fromkeys(CConfig.default_dic, ''))
-    @patch('cat_win.cat.config.load_config', lambda: Config.default_dic.copy())
+    @patch('cat_win.src.cat.cconfig.load_config', lambda: dict.fromkeys(CConfig.default_dic, ''))
+    @patch('cat_win.src.cat.config.load_config', lambda: Config.default_dic.copy())
     def setUp(self):
         """
         the config patches are neccessary for the setup() function.
         in the other TestCases this function is called indirectly through main() or shell_main()
         in that case the patch can be applied on the class-level (therefor on every test-method)
         in this case only needed in setUp().
         using start and stop to manage the patch lifecycle is not needed, since the test-method
@@ -36,167 +36,167 @@
         cat.setup()
 
     def tearDown(self):
         cat._calculate_line_prefix_spacing.cache_clear()
         cat._calculate_line_length_prefix_spacing.cache_clear()
 
     def test_cat_output_default_file(self):
-        cat.holder.set_files([test_file_path])
-        cat.holder.set_args([])
+        cat.u_files.set_files([test_file_path])
+        cat.u_args.set_args([])
 
         check_against = '\n'.join(test_file_content) + '\n'
 
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.edit_files()
             self.assertEqual(fake_out.getvalue(), check_against)
 
     def test_cat_output_multiple_files(self):
-        cat.holder.set_files([test_file_path, test_file_path, test_file_path])
-        cat.holder.set_args([])
+        cat.u_files.set_files([test_file_path, test_file_path, test_file_path])
+        cat.u_args.set_args([])
 
         check_against = '\n'.join(test_file_content * 3) + '\n'
 
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.edit_files()
             self.assertEqual(fake_out.getvalue(), check_against)
 
     def test_cat_output_reverse(self):
-        cat.holder.set_files([test_file_path])
-        cat.holder.set_args([(ARGS_REVERSE, '')]) #reverse
+        cat.u_files.set_files([test_file_path])
+        cat.u_args.set_args([(ARGS_REVERSE, '')]) #reverse
 
         check_against = test_file_content
         check_against.reverse()
         check_against = '\n'.join(check_against) + '\n'
 
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.edit_files()
             self.assertEqual(fake_out.getvalue(), check_against)
 
     def test_cat_output_ends_and_tabs(self):
-        cat.holder.set_files([test_file_path])
-        cat.holder.set_args([(ARGS_ENDS, ''), (ARGS_CHR, '')]) #ends & char
+        cat.u_files.set_files([test_file_path])
+        cat.u_args.set_args([(ARGS_ENDS, ''), (ARGS_CHR, '')]) #ends & char
 
         check_against = ('\n'.join(c.replace('\t', '^TAB') + '$' for c in test_file_content) +
                          '\n')
 
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.edit_files()
             self.assertEqual(fake_out.getvalue(), check_against)
 
     def test_cat__get_line_prefix_file_excess(self):
-        cat.holder.all_line_number_place_holder = 5
+        cat.u_files.all_line_number_place_holder = 5
         self.assertEqual(cat._get_line_prefix(9, 1), '    9) ')
 
     def test_cat__get_line_prefix_file_occupied(self):
-        cat.holder.all_line_number_place_holder = 2
+        cat.u_files.all_line_number_place_holder = 2
         self.assertEqual(cat._get_line_prefix(10, 1), '10) ')
 
     def test_cat__get_line_prefix_file_excess_long(self):
-        cat.holder.all_line_number_place_holder = 12
+        cat.u_files.all_line_number_place_holder = 12
         self.assertEqual(cat._get_line_prefix(34719, 1), '       34719) ')
 
     def test_cat__get_line_prefix_file_occupied_long(self):
-        cat.holder.all_line_number_place_holder = 5
+        cat.u_files.all_line_number_place_holder = 5
         self.assertEqual(cat._get_line_prefix(34718, 1), '34718) ')
 
     def test_cat__get_line_prefix_files_excess(self):
-        cat.holder.all_line_number_place_holder = 5
-        cat.holder.file_number_place_holder = 4
-        cat.holder.files = [1,2]
+        cat.u_files.all_line_number_place_holder = 5
+        cat.u_files.file_number_place_holder = 4
+        cat.u_files.files = [1,2]
         self.assertEqual(cat._get_line_prefix(9, 1), '   1.    9) ')
 
     def test_cat__get_line_prefix_files_occupied(self):
-        cat.holder.all_line_number_place_holder = 3
-        cat.holder.file_number_place_holder = 2
-        cat.holder.files = [1,2]
+        cat.u_files.all_line_number_place_holder = 3
+        cat.u_files.file_number_place_holder = 2
+        cat.u_files.files = [1,2]
         self.assertEqual(cat._get_line_prefix(987, 10), '10.987) ')
 
     def test_cat__get_line_prefix_files_excess_long(self):
-        cat.holder.all_line_number_place_holder = 12
-        cat.holder.file_number_place_holder = 10
-        cat.holder.files = [1,2]
+        cat.u_files.all_line_number_place_holder = 12
+        cat.u_files.file_number_place_holder = 10
+        cat.u_files.files = [1,2]
         self.assertEqual(cat._get_line_prefix(101, 404), '       404.         101) ')
 
     def test_cat__get_line_prefix_files_occupied_long(self):
-        cat.holder.all_line_number_place_holder = 11
-        cat.holder.file_number_place_holder = 9
-        cat.holder.files = [1,2]
+        cat.u_files.all_line_number_place_holder = 11
+        cat.u_files.file_number_place_holder = 9
+        cat.u_files.files = [1,2]
         self.assertEqual(cat._get_line_prefix(12345123451, 123456789), '123456789.12345123451) ')
 
     def test_cat__get_line_length_prefix_string_excess(self):
-        cat.holder.file_line_length_place_holder = 5
-        cat.holder.set_args([])
+        cat.u_files.file_line_length_place_holder = 5
+        cat.u_args.set_args([])
         self.assertEqual(cat._get_line_length_prefix('testtest', 'abcdefghi'), 'testtest[    9] ')
 
     def test_cat__get_line_length_prefix_string_occupied(self):
-        cat.holder.file_line_length_place_holder = 2
-        cat.holder.set_args([])
+        cat.u_files.file_line_length_place_holder = 2
+        cat.u_args.set_args([])
         self.assertEqual(cat._get_line_length_prefix('prefix', 'abcdefghij'), 'prefix[10] ')
 
     def test_cat__get_line_length_prefix_bytes_excess(self):
-        cat.holder.file_line_length_place_holder = 5
-        cat.holder.set_args([])
+        cat.u_files.file_line_length_place_holder = 5
+        cat.u_args.set_args([])
         self.assertEqual(cat._get_line_length_prefix('testtest', b'abcdefghi'), 'testtest[    9] ')
 
     def test_cat__get_line_length_prefix_bytes_occupied(self):
-        cat.holder.file_line_length_place_holder = 2
-        cat.holder.set_args([])
+        cat.u_files.file_line_length_place_holder = 2
+        cat.u_args.set_args([])
         self.assertEqual(cat._get_line_length_prefix('prefix', b'abcdefghij'), 'prefix[10] ')
 
     def test_remove_ansi_codes_from_line(self):
         red = '\x1b[31m'
         reset = '\x1b[0m'
         random_string = f"abc{red}defghij{reset}klmnopq{red}r{reset}"
         expected_output = 'abcdefghijklmnopqr'
         self.assertEqual(cat.remove_ansi_codes_from_line(random_string), expected_output)
 
-    @patch('cat_win.cat.print_update_information', new=lambda *_: '')
+    @patch('cat_win.src.cat.print_update_information', new=lambda *_: '')
     def test__show_help(self):
         stdin_mock = StdInMock()
         stdin_mock.set_content('\n\n\n')
         with patch('sys.stdin', new=stdin_mock), patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat._show_help()
             for arg in cat.ALL_ARGS:
                 if arg.show_arg:
                     self.assertIn(arg.short_form, fake_out.getvalue())
                     self.assertIn(arg.long_form, fake_out.getvalue())
                     self.assertIn(arg.arg_help, fake_out.getvalue())
 
-    @patch('cat_win.cat.print_update_information', new=lambda *_: '')
+    @patch('cat_win.src.cat.print_update_information', new=lambda *_: '')
     def test__show_help_shell(self):
         stdin_mock = StdInMock()
         stdin_mock.set_content('\n\n\n')
         with patch('sys.stdin', new=stdin_mock), patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat._show_help(True)
             for arg in cat.ALL_ARGS:
                 if arg.show_arg and arg.show_arg_on_shell:
                     self.assertIn(arg.short_form, fake_out.getvalue())
                     self.assertIn(arg.long_form, fake_out.getvalue())
                     self.assertIn(arg.arg_help, fake_out.getvalue())
                 elif arg.show_arg:
                     self.assertNotIn(arg.arg_help, fake_out.getvalue())
 
-    @patch('cat_win.cat.print_update_information', new=lambda *_: '')
+    @patch('cat_win.src.cat.print_update_information', new=lambda *_: '')
     def test__show_version(self):
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat._show_version()
             self.assertIn('Catw', fake_out.getvalue())
             self.assertIn('Author', fake_out.getvalue())
 
-    @patch('cat_win.cat.arg_parser.file_search', new=set([('hello', False), ('world', True)]))
+    @patch('cat_win.src.cat.arg_parser.file_search', new=set([('hello', False), ('world', True)]))
     def test__show_debug(self):
         with patch('sys.stderr', new=StdOutMock()) as fake_out:
             cat._show_debug([], ['test'], [], [], [], [])
             self.assertIn('test', fake_out.getvalue())
             self.assertIn('DEBUG', fake_out.getvalue())
             self.assertIn('hello', fake_out.getvalue())
             self.assertIn('world', fake_out.getvalue())
             self.assertIn('CS', fake_out.getvalue())
             self.assertIn('CI', fake_out.getvalue())
 
     def test__get_file_prefix(self):
-        cat.holder.files = [File('a', 'b/c.x')]
+        cat.u_files.files = [File('a', 'b/c.x')]
         cat.file_uri_prefix = 'test_uri/'
         prefix = cat._get_file_prefix('pre ', 0, True)
         self.assertEqual(prefix, 'pre test_uri/b/c.x ')
 
 # python -m unittest discover -s cat_win.tests -p test*.py
```

## Comparing `cat_win/tests/test_cconfig.py` & `cat_win/tests/src/persistence/test_cconfig.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from unittest.mock import patch
 from unittest import TestCase
 import os
 
-from cat_win.const.colorconstants import ColorOptions, CKW
+from cat_win.src.const.colorconstants import ColorOptions, CKW
 from cat_win.tests.mocks.std import StdOutMock
-from cat_win.persistence.cconfig import CConfig
+from cat_win.src.persistence.cconfig import CConfig
 # import sys
 # sys.path.append('../cat_win')
 
 
 test_file_dir = os.path.join(os.path.dirname(__file__), 'texts')
 config = CConfig(test_file_dir)
 config.load_config()
```

## Comparing `cat_win/tests/test_checksum.py` & `cat_win/tests/src/service/test_checksum.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 from unittest import TestCase
 import os
 
-from cat_win.util.service.checksum import get_checksum_from_file
+from cat_win.src.service.checksum import get_checksum_from_file
 # import sys
 # sys.path.append('../cat_win')
 
 
-test_file_path = os.path.join(os.path.dirname(__file__), 'texts', 'test.txt')
+test_file_path = os.path.join(os.path.dirname(__file__), '..', '..', 'texts', 'test.txt')
 
 
 class TestChecksum(TestCase):
     def test_checksum(self):
         expected_output = ''
         expected_output += '\tCRC32:   C7222F64\n'
         expected_output += '\tMD5:     0f85f8d2b6783c06d40755ab54906862\n'
```

## Comparing `cat_win/tests/test_config.py` & `cat_win/tests/src/persistence/test_config.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from unittest.mock import patch
 from unittest import TestCase
 import os
 
-from cat_win.const.defaultconstants import DKW
+from cat_win.src.const.defaultconstants import DKW
 from cat_win.tests.mocks.std import StdOutMock
-from cat_win.persistence.config import Config
+from cat_win.src.persistence.config import Config
 # import sys
 # sys.path.append('../cat_win')
 
 
 test_file_dir = os.path.join(os.path.dirname(__file__), 'texts')
 config = Config(test_file_dir)
 config.load_config()
```

## Comparing `cat_win/tests/test_converter.py` & `cat_win/tests/src/service/test_converter.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from unittest import TestCase
 
-from cat_win.util.service.converter import Converter
+from cat_win.src.service.converter import Converter
 # import sys
 # sys.path.append('../cat_win')
 
 
 converter = Converter()
 debug_converter = Converter()
 debug_converter.set_params(True)
```

## Comparing `cat_win/tests/test_editor.py` & `cat_win/tests/src/service/test_editor.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,33 +1,28 @@
 from unittest.mock import patch
 from unittest import TestCase
 import os
 
 from cat_win.tests.mocks.error import ErrorDefGen
 from cat_win.tests.mocks.std import StdOutMock
 from cat_win.tests.mocks.edit import getxymax
-from cat_win.util.service.editor import Editor, get_newline
+from cat_win.src.service.editor import Editor
 # import sys
 # sys.path.append('../cat_win')
-test_file_dir = os.path.join(os.path.dirname(__file__), 'texts')
+test_file_dir = os.path.join(os.path.dirname(__file__), '..', '..', 'texts')
 test_file_path  = os.path.join(test_file_dir, 'test.txt')
 test_file_path_empty = os.path.join(test_file_dir, 'test_empty.txt')
 test_file_path_oneline = os.path.join(test_file_dir, 'test_oneline.txt')
 test_file_path_editor = os.path.join(test_file_dir, 'test_editor.txt')
 
 
-@patch('cat_win.util.service.editor.Editor.getxymax', getxymax)
+@patch('cat_win.src.service.editor.Editor.getxymax', getxymax)
 class TestEditor(TestCase):
     maxDiff = None
 
-    def test_get_newline(self):
-        self.assertEqual(get_newline(test_file_path), '\r\n')
-        self.assertEqual(get_newline(test_file_path_empty), '\n')
-        self.assertEqual(get_newline(test_file_path_oneline), '\n')
-
     def test_editor_special_chars(self):
         editor = Editor(test_file_path_oneline, '')
         self.assertEqual(editor._get_special_char('\b'), '?')
 
         editor._set_special_chars({'\b': '!'})
         self.assertEqual(editor._get_special_char('\b'), '!')
 
@@ -344,15 +339,15 @@
         for _ in range(61):
             editor._key_enter('')
         editor._key_string('!' * 150)
         editor.wpos.set_pos((33, 37))
         editor._scroll_key_home()
         self.assertEqual(editor.wpos.get_pos(), (0,0))
 
-    @patch('cat_win.util.service.editor.Editor.special_indentation', ':)')
+    @patch('cat_win.src.service.editor.Editor.special_indentation', ':)')
     def test_editor_key_btab(self):
         editor = Editor(test_file_path_editor, '')
         editor._key_string(':):)')
         editor._key_string('\t')
         self.assertListEqual(editor.window_content, [':):):)line 1', 'line 2'])
         editor._move_key_ctl_right()
         self.assertEqual(editor._key_btab(''), ':)')
@@ -367,15 +362,15 @@
     def test_editor_key_btab_reverse(self):
         editor = Editor(test_file_path_editor, '')
         editor.cpos.set_pos((0,4))
         editor._key_btab_reverse(':)')
         self.assertListEqual(editor.window_content, [':)line 1', 'line 2'])
         self.assertEqual(editor.cpos.get_pos(), (0,6))
 
-    @patch('cat_win.util.service.editor.Editor.special_indentation', '!!!')
+    @patch('cat_win.src.service.editor.Editor.special_indentation', '!!!')
     def test_editor_key_string(self):
         editor = Editor(test_file_path_editor, '')
         self.assertEqual(editor._key_string(1), '')
         self.assertEqual(editor._key_string(''), '')
         self.assertListEqual(editor.window_content, ['line 1', 'line 2'])
         editor._move_key_right()
         editor._key_string('test')
@@ -412,15 +407,15 @@
         editor = Editor(test_file_path_oneline, '')
         with self.assertRaises(KeyboardInterrupt):
             with patch('sys.stderr', new=StdOutMock()) as fake_out:
                 editor._action_interrupt(None)
                 self.assertEqual('Interrupting...\n', fake_out.getvalue())
         Editor.debug_mode = False
 
-    @patch('cat_win.util.service.editor.CURSES_MODULE_ERROR', new=True)
+    @patch('cat_win.src.service.editor.CURSES_MODULE_ERROR', new=True)
     def test_editor_no_curses_error(self):
         with patch('sys.stderr', new=StdOutMock()) as fake_out:
             self.assertEqual(Editor.open('', '', None, True), False)
             self.assertIn('could not be loaded', fake_out.getvalue())
             self.assertIn('windows-curses', fake_out.getvalue())
 
     def test_editor_set_indentation(self):
```

## Comparing `cat_win/tests/test_file.py` & `cat_win/tests/src/domain/test_file.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from unittest import TestCase
 
-from cat_win.util.helper.file import File
+from cat_win.src.domain.file import File
 # import sys
 # sys.path.append('../cat_win')
 
 
 class TestFile(TestCase):
     def test_file_default(self):
         file = File('TestPath', 'TestName')
```

## Comparing `cat_win/tests/test_fileattributes.py` & `cat_win/tests/src/service/test_fileattributes.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from unittest import TestCase
 
-from cat_win.util.service.fileattributes import _convert_size, get_file_meta_data, get_file_size
+from cat_win.src.service.fileattributes import _convert_size, get_file_meta_data, get_file_size
 # import sys
 # sys.path.append('../cat_win')
 
 
 class TestFileAttributes(TestCase):
     def test__convert_size_zero(self):
         self.assertEqual(_convert_size(0), '0  B')
```

## Comparing `cat_win/tests/test_full.py` & `cat_win/tests/src/test_full.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from unittest.mock import patch
 from unittest import TestCase
 import os
 
-from cat_win import cat
-from cat_win.const.defaultconstants import DKW
+from cat_win.src import cat
+from cat_win.src.const.defaultconstants import DKW
 from cat_win.tests.mocks.std import StdInMock, StdOutMock
-from cat_win.persistence.cconfig import CConfig
-from cat_win.persistence.config import Config
+from cat_win.src.persistence.cconfig import CConfig
+from cat_win.src.persistence.config import Config
 # import sys
 # sys.path.append('../cat_win')
 
 
-test_file_dir = os.path.join(os.path.dirname(__file__), 'texts')
-test_res_dir  = os.path.join(os.path.dirname(__file__), 'resources')
+test_file_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'texts'))
+test_res_dir  = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'resources'))
 test_file_path  = os.path.join(test_file_dir, 'test.txt')
 test_empty_path = os.path.join(test_file_dir, 'test_empty.txt')
 test_peek       = os.path.join(test_file_dir, 'test_peek.txt')
 test_result_B   = os.path.join(test_file_dir, 'full_test_result_B.txt')
 test_result_C   = os.path.join(test_file_dir, 'full_test_result_C.txt')
 test_result_D   = os.path.join(test_file_dir, 'full_test_result_D.txt')
 test_eval       = os.path.join(test_file_dir, 'full_test_eval.txt')
 test_binary     = os.path.join(test_res_dir, 'test.bin')
 
 
 @patch('sys.stdin', StdInMock())
-@patch('cat_win.cat.cconfig.load_config', lambda: dict.fromkeys(CConfig.default_dic, ''))
-@patch('cat_win.cat.config.load_config', lambda: Config.default_dic.copy())
+@patch('cat_win.src.cat.cconfig.load_config', lambda: dict.fromkeys(CConfig.default_dic, ''))
+@patch('cat_win.src.cat.config.load_config', lambda: Config.default_dic.copy())
 class TestCatFull(TestCase):
     maxDiff = None
 
     def tearDown(self):
         cat._calculate_line_prefix_spacing.cache_clear()
         cat._calculate_line_length_prefix_spacing.cache_clear()
```

## Comparing `cat_win/tests/test_more.py` & `cat_win/tests/src/service/test_more.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from unittest import TestCase
 from unittest.mock import patch
 
 from cat_win.tests.mocks.std import StdInMock, StdOutMock, OSAttyDefGen
-from cat_win.util.service.more import More
+from cat_win.src.service.more import More
 
 
 bottom_line = '-' * 56 + 'cat_win' + '-' * 57
 
 # @patch('os.get_terminal_size', lambda: (120, 30))
 @patch('os.isatty', OSAttyDefGen.get_def({0: True, 1: True}))
 @patch('sys.stdin', new=StdInMock())
@@ -81,15 +81,15 @@
 
         more = More(['a'] * 59)
         with patch('builtins.input', input_mock), patch('sys.stdout', new=StdOutMock()) as fake_out:
             more.step_through()
             self.assertGreater(fake_out.getvalue().rfind(bottom_line), fake_out.getvalue().find(bottom_line))
             self.assertIn(bottom_line, fake_out.getvalue())
 
-    @patch('cat_win.util.service.more.More.step_length', 2)
+    @patch('cat_win.src.service.more.More.step_length', 2)
     def test_multiple_inputs_with_custom_step_size(self):
         def input_mock_helper():
             yield ''
             yield ''
 
         helper = input_mock_helper()
         def input_mock(_):
```

## Comparing `cat_win/tests/test_rawviewer.py` & `cat_win/tests/src/service/test_rawviewer.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from unittest import TestCase
 import os
 
-from cat_win.util.service.rawviewer import get_raw_view_lines_gen
+from cat_win.src.service.rawviewer import get_raw_view_lines_gen
 
 
-test_file_path = os.path.join(os.path.dirname(__file__), 'texts', 'test.txt')
+test_file_path = os.path.join(os.path.dirname(__file__), '..', '..', 'texts', 'test.txt')
 
 
 class TestRawViewer(TestCase):
     maxDiff = None
 
     def test_mode_x_upper(self):
         expected_result = """\
```

## Comparing `cat_win/tests/test_shell.py` & `cat_win/tests/src/test_shell.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,25 @@
 from unittest.mock import patch
 from unittest import TestCase
 
-from cat_win import cat
-from cat_win.tests.mocks.std import StdInHelperMock, StdOutMock
-from cat_win.persistence.cconfig import CConfig
-from cat_win.persistence.config import Config
+from cat_win.src import cat
+from cat_win.tests.mocks.std import StdInHelperMock, StdOutMock, StdInMock, OSAttyDefGen
+from cat_win.src.persistence.cconfig import CConfig
+from cat_win.src.persistence.config import Config
 # import sys
 # sys.path.append('../cat_win')
 stdinhelpermock = StdInHelperMock()
 
 
 @patch('sys.argv', ['<CAT>'])
-@patch('cat_win.util.helper.stdinhelper.get_stdin_content', stdinhelpermock.get_stdin_content)
-@patch('cat_win.cat.cconfig.load_config', lambda: dict.fromkeys(CConfig.default_dic, ''))
-@patch('cat_win.cat.config.load_config', lambda: Config.default_dic.copy())
+@patch('cat_win.src.service.helper.iohelper.IoHelper.get_stdin_content', stdinhelpermock.get_stdin_content)
+@patch('cat_win.src.cat.cconfig.load_config', lambda: dict.fromkeys(CConfig.default_dic, ''))
+@patch('cat_win.src.cat.config.load_config', lambda: Config.default_dic.copy())
+@patch('sys.stdin', StdInMock())
+@patch('os.isatty', OSAttyDefGen.get_def({0: True}))
 class TestShell(TestCase):
     maxDiff = None
 
     def tearDown(self):
         cat._calculate_line_prefix_spacing.cache_clear()
         cat._calculate_line_length_prefix_spacing.cache_clear()
 
@@ -68,24 +70,24 @@
             cat.shell_main()
             fake_output = [line.lstrip('>>> ') for line in fake_out.getvalue().splitlines()[2:-1]]
             self.assertListEqual(fake_output, expected_output)
 
     def test_cat_shell_see_param(self):
         stdinhelpermock.set_content('!add -ln FIND=test match=[0-9]\n!see')
         expected_output = ["successfully added ['-l', '-n'].", "Active Args: ['-l', '-n']",
-                           "Literals:    [('test', 'CI')]", "Matches:     [('[0-9]', 'CS')]"]
+                           "Literals:    [('test', 'CI')]", "Matches:     {re.compile('[0-9]', re.DOTALL)}"]
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.shell_main()
             fake_output = [line.lstrip('>>> ') for line in fake_out.getvalue().splitlines()[2:-1]]
             self.assertListEqual(fake_output, expected_output)
 
     def test_cat_shell_clear_param(self):
         stdinhelpermock.set_content('!add -ln find=test match=[0-9]\n!see\n!clear\n!see')
         expected_output = ["successfully added ['-l', '-n'].", "Active Args: ['-l', '-n']",
-                           "Literals:    [('test', 'CS')]", "Matches:     [('[0-9]', 'CS')]",
+                           "Literals:    [('test', 'CS')]", "Matches:     {re.compile('[0-9]', re.DOTALL)}",
                            "successfully removed ['-l', '-n'].", 'Active Args: []']
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             cat.shell_main()
             fake_output = [line.lstrip('>>> ') for line in fake_out.getvalue().splitlines()[2:-1]]
             self.assertListEqual(fake_output, expected_output)
 
     def test_cat_shell_exit(self):
```

## Comparing `cat_win/tests/test_stringfinder.py` & `cat_win/tests/src/service/test_stringfinder.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,12 @@
 from unittest import TestCase
 
-from cat_win.util.service.stringfinder import StringFinder
+import re
+
+from cat_win.src.service.stringfinder import StringFinder
 # import sys
 # sys.path.append('../cat_win')
 
 
 class TestStringFinder(TestCase):
     def test_find_literals_true(self):
         string_finder = StringFinder(set(), set())
@@ -26,29 +28,34 @@
         self.assertEqual(_x, [])
 
         _x = list(string_finder._findliterals('test', 'tsetabctesdeestf', False))
         self.assertEqual(_x, [])
 
     def test_find_regex_true(self):
         string_finder = StringFinder(set(), set())
-        _x = list(string_finder._findregex(r"[0-9]{2}", '123', False))
+        _x = list(string_finder._findregex(re.compile(r"test", re.DOTALL | re.IGNORECASE), 'TeSt'))
+        self.assertEqual(_x, [[0, 4]])
+
+    def test_find_regex_false(self):
+        string_finder = StringFinder(set(), set())
+        _x = list(string_finder._findregex(re.compile(r"[A-Z]{1}[a-z]+\s?.*\.+\s", re.DOTALL), 'silas A. Kraume'))
+        self.assertEqual(_x, [])
+        _x = list(string_finder._findregex(re.compile(r"[0-9]{2}", re.DOTALL), '123'))
         self.assertEqual(_x, [[0, 2]])
 
-        _x = list(string_finder._findregex(r"[0-9]{2}", '1234', False))
+        _x = list(string_finder._findregex(re.compile(r"[0-9]{2}", re.DOTALL), '1234'))
         self.assertEqual(_x, [[0, 2], [2, 4]])
 
-        _x = list(string_finder._findregex(r"[A-Z]{1}[a-z]*\s?.*\.+\s", 'Silas A. Kraume', False))
+        _x = list(string_finder._findregex(re.compile(r"[A-Z]{1}[a-z]*\s?.*\.+\s", re.DOTALL), 'Silas A. Kraume'))
         self.assertEqual(_x, [[0, 9]])
 
-        _x = list(string_finder._findregex(r"[A-Z]{1}[a-z]*\s?.*\.+\s", 'silas A. Kraume', False))
+        _x = list(string_finder._findregex(re.compile(r"[A-Z]{1}[a-z]*\s?.*\.+\s", re.DOTALL), 'silas A. Kraume'))
         self.assertEqual(_x, [[6, 9]])
 
-    def test_find_regex_false(self):
-        string_finder = StringFinder(set(), set())
-        _x = list(string_finder._findregex(r"[A-Z]{1}[a-z]+\s?.*\.+\s", 'silas A. Kraume', False))
+        _x = list(string_finder._findregex(re.compile(r"test", re.DOTALL), 'TeSt'))
         self.assertEqual(_x, [])
 
     def test_optimize_intervals(self):
         string_finder = StringFinder(set(), set())
         _x = string_finder._optimize_intervals([[1, 3], [3, 5]])
         self.assertEqual(_x, [[1, 5]])
 
@@ -66,15 +73,15 @@
         _x = string_finder._optimize_intervals([])
         self.assertEqual(_x, [])
 
     def test_find_keywords(self):
         string_finder = StringFinder(set([('Is', False),
                                           ('Test', False),
                                           ('Not', False)]),
-                                     set([(r"[0-9]\!", False)]))
+                                     set([re.compile(r"[0-9]\!", re.DOTALL)]))
         line = 'ThisIsATest!1!'
         intervals, f_keywords, m_keywords = string_finder.find_keywords(line)
 
         self.assertCountEqual(intervals, [[14, 'reset_matched'], [12, 'matched_pattern'],
                                           [11, 'reset_found'], [7, 'found_keyword'],
                                           [6, 'reset_found'], [4, 'found_keyword']])
         self.assertCountEqual(f_keywords, [('Is', [4, 6]), ('Test', [7, 11])])
```

## Comparing `cat_win/tests/test_strings.py` & `cat_win/tests/src/service/test_strings.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 from unittest import TestCase
 import os
 
-from cat_win.util.service.strings import get_strings
+from cat_win.src.service.strings import get_strings
 # import sys
 # sys.path.append('../cat_win')
 
 
-test_file_dir = os.path.join(os.path.dirname(__file__), 'resources')
+test_file_dir = os.path.join(os.path.dirname(__file__), '..', '..', 'resources')
 test_file_path = os.path.join(test_file_dir, 'test.bin')
 with open(test_file_path, 'r', encoding='utf-8', errors='replace') as raw_f:
     test_content = [('', line) for line in raw_f.read().splitlines()]
 
 class TestFile(TestCase):
     def test_get_strings_default(self):
         # unix : "strings test.bin"
```

## Comparing `cat_win/tests/test_summary.py` & `cat_win/tests/src/service/test_summary.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 from unittest import TestCase
 from unittest.mock import patch
 import os
 
 from cat_win.tests.mocks.std import StdOutMock
-from cat_win.util.helper.file import File
-from cat_win.util.service.summary import Summary
+from cat_win.src.domain.file import File
+from cat_win.src.service.summary import Summary
 
-test_file_path = os.path.join(os.path.dirname(__file__), 'texts', 'test.txt')
+test_file_path = os.path.join(os.path.dirname(__file__), '..', '..', 'texts', 'test.txt')
 
 
 class TestSummary(TestCase):
     def test_show_dirs(self):
         with patch('sys.stdout', new=StdOutMock()) as fake_out:
             Summary.show_dirs(['dirA', 'dirB'])
             self.assertIn('dirA', fake_out.getvalue())
```

## Comparing `cat_win/tests/test_updatechecker.py` & `cat_win/tests/src/web/test_updatechecker.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from unittest import TestCase
 
-from cat_win.web import updatechecker
+from cat_win.src.web import updatechecker
 # import sys
 # sys.path.append('../cat_win')
 
 
 class TestUpdateChecker(TestCase):
     def test_only_numeric(self):
         self.assertEqual(updatechecker.only_numeric('1nh589h15io125b085218'), 158915125085218)
```

## Comparing `cat_win/tests/test_urls.py` & `cat_win/tests/src/web/test_urls.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from unittest.mock import patch
 from unittest import TestCase
 import random
 
 from cat_win.tests.mocks.error import ErrorDefGen
-from cat_win.web.urls import is_valid_uri, sep_valid_urls, read_url
+from cat_win.src.web.urls import is_valid_uri, sep_valid_urls, read_url
 
 class TestUrls(TestCase):
     def test_is_valid_uri_valueerror(self):
         self.assertEqual(is_valid_uri('invalid uri'), False)
 
     def test_sep_valid_urls(self):
         random.seed(1)
```

## Comparing `cat_win/tests/test_utility.py` & `cat_win/tests/src/service/helper/test_utility.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 from unittest import TestCase
 
-from cat_win.const.argconstants import ARGS_EVAL, ALL_ARGS
-from cat_win.cat import remove_ansi_codes_from_line as cleaner
-from cat_win.util.service.converter import Converter
+from cat_win.src.const.argconstants import ARGS_EVAL, ALL_ARGS
+from cat_win.src.cat import remove_ansi_codes_from_line as cleaner
+from cat_win.src.service.converter import Converter
 try:
-    from cat_win.util.helper.utility import comp_eval, comp_conv
+    from cat_win.src.service.helper.utility import comp_eval, comp_conv
 except SyntaxError: # in case of Python 3.7
-    from cat_win.util.helper.utilityold import comp_eval, comp_conv
+    from cat_win.src.service.helper.utilityold import comp_eval, comp_conv
 
 # import sys
 # sys.path.append('../cat_win')
 converter = Converter()
 param_lowercase, param_uppercase = '', ''
 for arg in ALL_ARGS:
     if arg.arg_id == ARGS_EVAL:
```

## Comparing `cat_win/tests/test_zipviewer.py` & `cat_win/tests/src/service/helper/test_zipviewer.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from unittest.mock import patch
 from unittest import TestCase
 import os
 
 from cat_win.tests.mocks.std import StdOutMock
-from cat_win.util.helper.zipviewer import display_zip
+from cat_win.src.service.helper.zipviewer import display_zip
 # import sys
 # sys.path.append('../cat_win')
-test_file_dir = os.path.join(os.path.dirname(__file__), 'texts')
+test_file_dir = os.path.join(os.path.dirname(__file__), '..', '..', '..', 'texts')
 test_file_path  = os.path.join(test_file_dir, 'test.txt')
-test_zip_file_dir = os.path.join(os.path.dirname(__file__), 'resources')
-test_zip_file_path  = os.path.join(test_zip_file_dir, 'test.zip')
+test_zip_file_dir = os.path.join(os.path.dirname(__file__), '..', '..', '..', 'resources')
+test_zip_file_path  = os.path.abspath(os.path.join(test_zip_file_dir, 'test.zip'))
 
 
 class TestZipviewer(TestCase):
     maxDiff = None
 
     def test_display_zip_bad_file(self):
         self.assertEqual(display_zip('', lambda x: x), False)
```

## Comparing `cat_win/util/argparser.py` & `cat_win/src/argparser.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,31 +1,19 @@
 """
 argparser
 """
 
 import glob
 import os
-import re
-
-from cat_win.const.argconstants import ALL_ARGS, ARGS_CUT, ARGS_REPLACE, ARGS_ECHO
 
+from cat_win.src.const.argconstants import ALL_ARGS, ARGS_CUT, ARGS_REPLACE, ARGS_ECHO
+from cat_win.src.const.regex import compile_re
+from cat_win.src.const.regex import RE_ENCODING, RE_MATCH, RE_FIND, RE_TRUNC, RE_CUT, RE_REPLACE, RE_REPLACE_COMMA
 
 IS_FILE, IS_DIR, IS_PATTERN = range(0, 3)
-RE_ENCODING      = re.compile(r"\Aenc[\=\:].+\Z",     re.IGNORECASE)
-RE_MATCH         = re.compile(r"\Amatch[\=\:].+\Z",   re.IGNORECASE)
-RE_FIND          = re.compile(r"\Afind[\=\:].*\Z",    re.IGNORECASE)
-RE_TRUNC         = re.compile(r"\Atrunc[\=\:][0-9\(\)\+\-\*\/]*"
-                              r"\:[0-9\(\)\+\-\*\/]*\:?"
-                              r"[0-9\(\)\+\-\*\/]*\Z")
-RE_CUT           = re.compile(r"\A\[[0-9\(\)\+\-\*\/]*\:"
-                              r"[0-9\(\)\+\-\*\/]*\:?"
-                              r"[0-9\(\)\+\-\*\/]*\]\Z")
-RE_REPLACE       = re.compile(r"\A\[(.*?(?<!\\)(?:\\\\)*),(.*)\]\Z")
-RE_REPLACE_COMMA = re.compile(r"(?<!\\)((?:\\\\)*)\\,")
-# using simple if-statements (e.g. startwith()) would be faster, but arguably less readable
 
 
 def levenshtein(str_a: str, str_b: str) -> float:
     """
     Calculate the levenshtein distance (similarity) between
     two strings and return the result as a percentage value.
     char case is ignored such that uppercase letters match their
@@ -235,17 +223,17 @@
         # 'enc' + ('=' or ':') + file_encoding
         if RE_ENCODING.match(param):
             self.file_encoding = param[4:]
             return False
         # 'match' + ('=' or ':') + file_match
         if RE_MATCH.match(param):
             if delete:
-                self.file_match.discard((param[6:], param[:5].isupper()))
+                self.file_match.discard(compile_re(param[6:], param[:5].isupper()))
                 return False
-            self.file_match.add((param[6:], param[:5].isupper()))
+            self.file_match.add(compile_re(param[6:], param[:5].isupper()))
             return False
         # 'find' + ('=' or ':') + file_search
         if RE_FIND.match(param):
             if delete:
                 self.file_search.discard((param[5:], param[:4].isupper()))
                 return False
             query = param[5:]
@@ -268,24 +256,24 @@
         # '[' + ARGS_CUT + ']'
         if RE_CUT.match(param):
             self._args.append((ARGS_CUT, param))
             return False
         # '[' + ARGS_REPLACE_THIS + ',' + ARGS_REPLACE_WITH + ']' (escape chars with '\')
         if RE_REPLACE.match(param):
             re_match = RE_REPLACE.match(param)
-            re_this = re.sub(RE_REPLACE_COMMA, r"\1,", re_match.group(1))
-            re_with = re.sub(RE_REPLACE_COMMA, r"\1,", re_match.group(2))
+            re_this = RE_REPLACE_COMMA.sub(r"\1,", re_match.group(1))
+            re_with = RE_REPLACE_COMMA.sub(r"\1,", re_match.group(2))
             try:
                 if self.unicode_replace:
                     re_this = re_this.encode().decode('unicode_escape').encode('latin-1').decode()
                     re_with = re_with.encode().decode('unicode_escape').encode('latin-1').decode()
             except UnicodeError:
                 pass
             finally:
-                self.file_replace_mapping[param] = ((re_this, re_with))
+                self.file_replace_mapping[param] = (re_this, re_with)
             self._args.append((ARGS_REPLACE, param))
             return False
 
         # default parameters
         for arg in ALL_ARGS:
             if param in (arg.short_form, arg.long_form):
                 self._args.append((arg.arg_id, param))
```

## Comparing `cat_win/util/helper/editorhelper.py` & `cat_win/src/service/helper/editorhelper.py`

 * *Files identical despite different names*

## Comparing `cat_win/util/helper/file.py` & `cat_win/src/domain/file.py`

 * *Files identical despite different names*

## Comparing `cat_win/util/helper/stdinhelper.py` & `cat_win/src/service/helper/iohelper.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,68 +1,24 @@
 """
-stdinhelper
+iohelper
 """
 
 import contextlib
 import ctypes
 import os
 import sys
 
 
-def write_file(content, src_file: str, file_encoding: str) -> str:
+def err_print(*args, **kwargs):
     """
-    Writes content into a generated temp-file.
-    
-    Parameters:
-    content (str|bytes):
-        the content to write in a file
-    src_file (str):
-        a string representation of a file (-path)
-    file_encoding (str):
-        an encoding the open the file with
-    
-    Returns:
-    src_file (str):
-        the path to the temporary file written
+    print to stderr.
     """
-    if isinstance(content, str):
-        with open(src_file, 'w', encoding=file_encoding, errors='replace') as file:
-            file.write(content)
-        return src_file
-    # in case the content is of types bytes:
-    # important for the editor, so the encoding errors do not get replaced!
-    with open(src_file, 'wb') as raw_f:
-        raw_f.write(content)
-    return src_file
-
-
-def get_stdin_content(one_line: bool = False):
-    """
-    read the stdin.
-    
-    Parameters:
-    one_line (bool):
-        determines if only the first stdin line should be read
-        
-    Yields:
-    line (str):
-        the input (line by line) delivered by stdin
-        until the first EOF (Chr(26)) character
-    """
-    if one_line:
-        first_line = sys.stdin.readline().rstrip('\n')
-        if first_line[-1:] == chr(26):
-            first_line = first_line[:-1]
-        yield first_line
-        return
-    for line in sys.stdin:
-        if line[-2:-1] == chr(26):
-            yield line[:-2]
-            break
-        yield line
+    kwargs['file']  = sys.stderr
+    kwargs['flush'] = True
+    print(*args, **kwargs)
 
 
 def path_parts(path: str) -> list:
     """
     split a path recursively into its parts.
     
     Parameters:
@@ -98,159 +54,280 @@
     file_dir = os.path.dirname(file)
     splitted_path = path_parts(file_dir)
     subpaths = [os.path.join(*splitted_path[:i]) for i in range(2, len(splitted_path)+1)]
     unknown_subpaths = [s for s in subpaths[::-1] if not os.path.exists(s)]
     try:
         os.makedirs(file_dir, exist_ok=True)
     except OSError:
-        print(f"Error: The path '{file_dir}' could not be created.", file=sys.stderr)
+        err_print(f"Error: The path '{file_dir}' could not be created.")
         # cleanup (delete the folders that have been created)
         for subpath in unknown_subpaths:
             try:
                 os.rmdir(subpath)
             except OSError:
                 continue
         return False
     try:
-        write_file(content, file, file_encoding)
+        IoHelper.write_file(file, content, file_encoding)
     except OSError:
-        print(f"Error: The file '{file}' could not be written.", file=sys.stderr)
+        err_print(f"Error: The file '{file}' could not be written.")
         # cleanup (delete the folders that have been created)
         for subpath in unknown_subpaths:
             try:
                 os.rmdir(subpath)
             except OSError:
                 continue
         return False
     return True
 
 
-def write_files(file_list: list, content: str, file_encoding: str) -> list:
+class IoHelper:
     """
-    write to multiple files. ask if an empty file should be created
-    when there is nothing to write.
-    try to create the path to the files if it does not yet exist.
-    delete the created path again (cleanup) if the file still could
-    not be written.
-    
-    Parameters:
-    file_list (list):
-        all files that should be written
-    content (str):
-        the content to write into the files
-    file_encoding (str):
-        the encoding to open the files with
-    
-    Returns:
-    (list):
-        containing all files, that could succesfully be written.
+    IoHelper
     """
-    if not file_list:
-        return file_list
 
-    if content == '':
-        user_input = ''
-        try:
-            print('You are about to create an empty file. ', end='', file=sys.stderr)
-            print('Do you want to continue?', file=sys.stderr)
-            enter_char = '⏎'
-
-            try:
-                if len(enter_char.encode(file_encoding)) != 3:
-                    raise UnicodeEncodeError('', '', -1, -1, '')
-            except UnicodeEncodeError:
-                enter_char = 'ENTER'
-            print(f"[Y/{enter_char}] Yes, Continue       [N] No, Abort :", end='', file=sys.stderr)
-            user_input = input()
-        except EOFError:
-            pass
-        except UnicodeError:
-            print('Input is not recognized in the given encoding: ', end='', file=sys.stderr)
-            print(file_encoding, file=sys.stderr)
-            user_input = 'N'
-        finally:
-            if user_input and user_input.upper() != 'Y':
-                print('Aborting...', file=sys.stderr)
-                file_list.clear()
-
-    success_file_list = []
-
-    for file in file_list:
-        file = os.path.realpath(file)
+    @staticmethod
+    def read_file(src_file: str, binary: bool = False,
+                  file_encoding: str = 'utf-8', errors: str = 'replace') -> str:
+        """
+        Reades content from a given file.
+        
+        Parameters:
+        src_file (str):
+            a string representation of a file (-path)
+        binary (bool):
+            indicates if the file should be opened in binary mode
+        file_encoding (str):
+            an encoding the open the file with
+        errors (str):
+            the type of error handling when opening the file
+        
+        Returns:
+        src_content (str):
+            the content of the given file
+        """
+        src_content = None
+        if not binary:
+            with open(src_file, 'r', encoding=file_encoding, errors=errors) as file:
+                src_content = file.read()
+            return src_content
+        # in case the file should be opened in binary mode:
+        with open(src_file, 'rb') as file:
+            src_content = file.read()
+        return src_content
+
+
+    @staticmethod
+    def get_newline(file: str) -> str:
+        """
+        determines the line ending of a given file.
+        
+        Parameters:
+        file (str):
+            a file (-path) as string representation
+            
+        Returns:
+        (str):
+            the line ending that the given file is using
+            (\r or \n or \r\n)
+        """
         try:
-            write_file(content, file, file_encoding)
-            success_file_list.append(file)
-        except FileNotFoundError: # the os.pardir path to the file does not exist
-            if create_file(file, content, file_encoding):
-                success_file_list.append(file)
+            with open(file, 'rb') as _f:
+                _l = _f.readline()
+                _l += b'\n' * bool(not _l[-1:] or _l[-1:] not in b'\r\n')
+                return '\r\n' if _l[-2:] == b'\r\n' else _l[-1:].decode()
         except OSError:
-            print(f"Error: The file '{file}' could not be written.", file=sys.stderr)
+            return '\n'
 
-    return success_file_list
 
+    @staticmethod
+    def write_file(src_file: str, content,
+                   file_encoding: str = 'utf-8', errors: str = 'replace') -> str:
+        """
+        Writes content into a given file.
+        
+        Parameters:
+        content (str|bytes):
+            the content to write in a file
+        src_file (str):
+            a string representation of a file (-path)
+        file_encoding (str):
+            an encoding the open the file with
+        errors (str):
+            the type of error handling when opening the file
+        
+        Returns:
+        src_file (str):
+            the path to the temporary file written
+        """
+        if isinstance(content, str):
+            with open(src_file, 'w', encoding=file_encoding, errors=errors) as file:
+                file.write(content)
+            return src_file
+        # in case the content is of types bytes:
+        # important for the editor, so the encoding errors do not get replaced!
+        with open(src_file, 'wb') as raw_f:
+            raw_f.write(content)
+        return src_file
 
-def read_write_files_from_stdin(file_list: list, file_encoding: str, on_windows_os: bool,
-                                one_line: bool = False) -> list:
-    """
-    Write stdin input to multiple files.
-    
-    Parameters:
-    file_list (list):
-        all files that should be written
-    file_encoding (str):
-        the encoding to use for writing the files
-    on_windows_os (bool):
-        indicates if the user is on windows OS using
-        platform.system() == 'Windows'
-    one_line (bool):
-        determines if only the first stdin line should be read
+
+    @staticmethod
+    def get_stdin_content(one_line: bool = False, raw: bool = False):
+        """
+        read the stdin.
         
-    Returns:
-    (list):
-        containing all files, that could succesfully be written.
-    """
-    if not file_list:
-        return file_list
+        Parameters:
+        one_line (bool):
+            determines if only the first stdin line should be read
+            
+        Yields:
+        line (str):
+            the input (line by line) delivered by stdin
+            until the first EOF (Chr(26)) character
+        """
+        s_in = sys.stdin.buffer if raw else sys.stdin
+        if one_line:
+            first_line = s_in.readline().rstrip('\n')
+            if first_line.endswith(chr(26)):
+                first_line = first_line[:-1]
+            yield first_line
+            return
+        for line in s_in:
+            if line[-2:-1] == chr(26):
+                yield line[:-2]
+                break
+            yield line
+
+
+    @staticmethod
+    def write_files(file_list: list, content: str, file_encoding: str) -> list:
+        """
+        write to multiple files. ask if an empty file should be created
+        when there is nothing to write.
+        try to create the path to the files if it does not yet exist.
+        delete the created path again (cleanup) if the file still could
+        not be written.
+        
+        Parameters:
+        file_list (list):
+            all files that should be written
+        content (str):
+            the content to write into the files
+        file_encoding (str):
+            the encoding to open the files with
+        
+        Returns:
+        (list):
+            containing all files, that could succesfully be written.
+        """
+        if not file_list:
+            return file_list
 
-    print('The given FILE(s)', end='', file=sys.stderr)
-    print('', *file_list, sep='\n\t', file=sys.stderr)
-    eof_control_char = 'Z' if on_windows_os else 'D'
-    print('do/does not exist. Write the FILE(s) and finish with the ', end='', file=sys.stderr)
-    print(f"^{eof_control_char}-suffix (Ctrl + {eof_control_char}):", file=sys.stderr)
+        if content == '':
+            user_input = ''
+            try:
+                err_print('You are about to create an empty file. ', end='')
+                err_print('Do you want to continue?')
+                enter_char = '⏎'
+
+                try:
+                    if len(enter_char.encode(file_encoding)) != 3:
+                        raise UnicodeEncodeError('', '', -1, -1, '')
+                except UnicodeEncodeError:
+                    enter_char = 'ENTER'
+                err_print(f"[Y/{enter_char}] Yes, Continue       [N] No, Abort :", end='')
+                user_input = input()
+            except EOFError:
+                pass
+            except UnicodeError:
+                err_print('Input is not recognized in the given encoding: ', end='')
+                err_print(file_encoding)
+                user_input = 'N'
+            finally:
+                if user_input and user_input.upper() != 'Y':
+                    err_print('Aborting...')
+                    file_list.clear()
 
-    std_input = ''.join(get_stdin_content(one_line))
+        success_file_list = []
 
-    return write_files(file_list, std_input, file_encoding)
+        for file in file_list:
+            file = os.path.realpath(file)
+            try:
+                IoHelper.write_file(file, content, file_encoding)
+                success_file_list.append(file)
+            except FileNotFoundError: # the os.pardir path to the file does not exist
+                if create_file(file, content, file_encoding):
+                    success_file_list.append(file)
+            except OSError:
+                err_print(f"Error: The file '{file}' could not be written.")
 
+        return success_file_list
 
-@contextlib.contextmanager
-def dup_stdin(on_windows_os: bool, dup: bool = True):
-    """
-    dup the stdin so the user can interact while also piping into cat.
-    
-    Parameters:
-    on_windows_os (bool):
-        indicates if the current system is Windows
-    dup (bool):
-        is this is false the function will not do anything.
-        only implemented to eliminate repeated code somewhere else
-    """
-    if not dup:
-        yield
-        return
-    stdin_backup = os.dup(sys.stdin.fileno())
-    try:
-        tty = os.open('CONIN$' if on_windows_os else '/dev/tty', os.O_RDONLY)
-        os.dup2(tty, sys.stdin.fileno())
-        if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS') and on_windows_os:
-            # for pyinstaller:
-# stdin, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
-# None security, OPEN_EXISTING, 0 flags, None template
-            conin_handle = ctypes.windll.kernel32.CreateFileW(
-                "CONIN$", 0x80000000, 3, None, 3, 0, None
-                ) # os.dup2 does not work on pyinstaller
-            ctypes.windll.kernel32.SetStdHandle(-10, conin_handle) # -10 = stdin
-            # if this fails it is better to let the exception raise than to be stuck
-            # without user interaction being recognized
-        yield
-    finally:
-        os.dup2(stdin_backup, sys.stdin.fileno())
+
+    @staticmethod
+    def read_write_files_from_stdin(file_list: list, file_encoding: str, on_windows_os: bool,
+                                    one_line: bool = False) -> list:
+        """
+        Write stdin input to multiple files.
+        
+        Parameters:
+        file_list (list):
+            all files that should be written
+        file_encoding (str):
+            the encoding to use for writing the files
+        on_windows_os (bool):
+            indicates if the user is on windows OS using
+            platform.system() == 'Windows'
+        one_line (bool):
+            determines if only the first stdin line should be read
+            
+        Returns:
+        (list):
+            containing all files, that could succesfully be written.
+        """
+        if not file_list:
+            return file_list
+
+        err_print('The given FILE(s)', end='')
+        err_print('', *file_list, sep='\n\t')
+        eof_control_char = 'Z' if on_windows_os else 'D'
+        err_print('do/does not exist. Write the FILE(s) and finish with the ', end='')
+        err_print(f"^{eof_control_char}-suffix (Ctrl + {eof_control_char}):")
+
+        std_input = ''.join(IoHelper.get_stdin_content(one_line))
+
+        return IoHelper.write_files(file_list, std_input, file_encoding)
+
+
+    @staticmethod
+    @contextlib.contextmanager
+    def dup_stdin(on_windows_os: bool, dup: bool = True):
+        """
+        dup the stdin so the user can interact while also piping into cat.
+        
+        Parameters:
+        on_windows_os (bool):
+            indicates if the current system is Windows
+        dup (bool):
+            is this is false the function will not do anything.
+            only implemented to eliminate repeated code somewhere else
+        """
+        if not dup:
+            yield
+            return
+        stdin_backup = os.dup(sys.stdin.fileno())
+        try:
+            tty = os.open('CONIN$' if on_windows_os else '/dev/tty', os.O_RDONLY)
+            os.dup2(tty, sys.stdin.fileno())
+            if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS') and on_windows_os:
+                # for pyinstaller:
+    # stdin, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
+    # None security, OPEN_EXISTING, 0 flags, None template
+                conin_handle = ctypes.windll.kernel32.CreateFileW(
+                    "CONIN$", 0x80000000, 3, None, 3, 0, None
+                    ) # os.dup2 does not work on pyinstaller
+                ctypes.windll.kernel32.SetStdHandle(-10, conin_handle) # -10 = stdin
+                # if this fails it is better to let the exception raise than to be stuck
+                # without user interaction being recognized
+            yield
+        finally:
+            os.dup2(stdin_backup, sys.stdin.fileno())
```

## Comparing `cat_win/util/helper/tmpfilehelper.py` & `cat_win/src/service/helper/tmpfilehelper.py`

 * *Files identical despite different names*

## Comparing `cat_win/util/helper/utility.py` & `cat_win/src/service/helper/utility.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 """
 A collection of methods for list comprehension in regard to the converter.py module
 for Python >= 3.8 (using the Walrus operator).
 """
 
-from cat_win.util.service.converter import Converter
+from cat_win.src.service.converter import Converter
 
 
 def comp_eval(converter: Converter, content: list, param: str, cleaner: object) -> list:
     """
     comprehend the content list for the eval parameter
     
     Parameters:
```

## Comparing `cat_win/util/helper/utilityold.py` & `cat_win/src/service/helper/utilityold.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 """
 A collection of methods for list comprehension in regard to the converter.py module
 for Python < 3.8 (not using the Walrus operator).
 """
 
-from cat_win.util.service.converter import Converter
+from cat_win.src.service.converter import Converter
 
 
 def comp_eval(converter: Converter, content: list, param: str, cleaner: object) -> list:
     """
     comprehend the content list for the eval parameter
     
     Parameters:
```

## Comparing `cat_win/util/helper/winstreams.py` & `cat_win/src/service/helper/winstreams.py`

 * *Files identical despite different names*

## Comparing `cat_win/util/helper/zipviewer.py` & `cat_win/src/service/helper/zipviewer.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 """
 zipviewer
 """
 
-import sys
 import zipfile
 
+from cat_win.src.service.helper.iohelper import err_print
+
 
 def display_zip(file: str, size_converter) -> bool:
     """
     Parameters:
     file (str):
         a string representation of a file (-path)
     size_converter (method)
@@ -21,16 +22,16 @@
     try:
         file_info_list = [('FileName', 'FileSize', 'CompressedFileSize')]
         with zipfile.ZipFile(file, 'r') as zip_file:
             for file_info in zip_file.infolist():
                 file_info_list.append((file_info.filename,
                                        str(size_converter(file_info.file_size)),
                                        str(size_converter(file_info.compress_size))))
-        print(f"The file '{file}' has been detected to be a zip-file. ", end='', file=sys.stderr)
-        print('The archive contains the following files:', file=sys.stderr)
+        err_print(f"The file '{file}' has been detected to be a zip-file. ", end='')
+        err_print('The archive contains the following files:')
         length_list = [max(len(_f) for _f in f_info) for f_info in zip(*file_info_list)]
         for name, size, csize in file_info_list:
-            print(f"{name.ljust(length_list[0])} " + \
-                f"{size.rjust(length_list[1])} {csize.rjust(length_list[2])}", file=sys.stderr)
+            err_print(f"{name.ljust(length_list[0])} " + \
+                f"{size.rjust(length_list[1])} {csize.rjust(length_list[2])}")
         return True
     except (zipfile.BadZipfile, OSError):
         return False
```

## Comparing `cat_win/util/service/cbase64.py` & `cat_win/src/service/cbase64.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,101 +1,66 @@
 """
 cbase64
 """
 
 import base64
 
 
-def _encode_base64(content: str, encoding: str) -> bytes:
+def encode_base64(content, decode_bytes: bool = False,
+                  file_encoding: str = 'utf-8'):
     """
     Encode a string to base64.
     
     Parameters:
-    content (str):
-        the string to encode
-    encoding (str):
-        the encoding the string is using
+    content (bytes|str):
+        the content to encode in base64
+    decode_bytes (bool):
+        indicates if the returned value should be returned as
+        an decoded string, or as encoded bytes (default)
+    file_encoding (str):
+        the encoding to use when decoding the bytes to a string
         
     Returns:
-    encoded_content (bytes):
-        the base64 encoded string
+    encoded_content (bytes|str):
+        the base64 encoded content as string or bytes depending on decode_bytes
     """
-    # encode the string to bytes and encode with base64
-    content_bytes = content.encode(encoding=encoding)
-    encoded_content = base64.b64encode(content_bytes)
-
-    # return as a single line
-    return encoded_content
+    if isinstance(content, str):
+        content = content.encode(encoding=file_encoding, errors='ignore')
 
+    encoded_content = base64.b64encode(content)
 
-def encode_base64(content: list, encoding: str = 'utf-8') -> list:
-    """
-    Encode the file content to base64 by calling _encode_base64()
-    
-    Parameters:
-    content (list):
-        the file content represented as [(prefix, line), ...]
-    encoding (str):
-        the file encoding used
-        
-    Returns:
-    [('', encoded_content)] (list):
-        the encoded base64 content as a single line without any prefix
-    """
-    # concatenate all lines and join them with line breaks
-    content_lines = [''.join(x) for x in content]
-    content_line = '\n'.join(content_lines)
-
-    encoded_content = _encode_base64(content_line, encoding)
-    encoded_content = encoded_content.decode(encoding='ascii')
-    # return as a list containing a single line
-    return [('', encoded_content)]
+    if decode_bytes:
+        return encoded_content.decode(encoding='ascii')
+    return encoded_content
 
 
-def _decode_base64(content: str) -> bytes:
+def decode_base64(content: str, decode_bytes: bool = False,
+                  file_encoding: str = 'utf-8'):
     """
     Decode a string from base64.
     
     Parameters:
     content (str):
         the string to decode
+    decode_bytes (bool):
+        indicates if the returned value should be returned as
+        an decoded string, or as encoded bytes (default)
+    file_encoding (str):
+        the encoding to use when decoding the bytes to a string
         
     Returns:
-    decoded_content (bytes):
-        the base64 decoded string
+    decoded_content (bytes|str):
+        the base64 decoded content as string or bytes depending on decode_bytes
     """
     chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
 
+    # base64.b64decode() would raise an error on corrupted base64.
+    # the following algorithm decodes as much as possible:
     binary_str = ''.join(f"{chars.index(char):06b}" for char in content if char in chars)
     if len(binary_str) % 8 != 0:
         binary_str = binary_str[:-(len(binary_str)%8)]
     decoded_content = bytearray()
     decoded_content.extend([int(binary_str[i:i+8], 2) for i in range(0, len(binary_str), 8)])
 
-    # return as a single line
+    if decode_bytes:
+        return decoded_content.decode(file_encoding, errors='ignore')
     return decoded_content
-
-
-def decode_base64(content: list, encoding: str = 'utf-8') -> list:
-    """
-    decode the file content from base64 by calling _decode_base64()
-    
-    Parameters:
-    content (list):
-        the file content represented as [(prefix, line), ...]
-    encoding (str):
-        the file encoding used
-        
-    Returns:
-    [('', line), ...] (list):
-        the decoded base64 content line by line without any prefix
-    """
-    # concatenate all lines and join them
-    content_lines = [x for _, x in content]
-    content_line = ''.join(content_lines)
-
-    decoded_content = _decode_base64(content_line)
-    decoded_content = decoded_content.decode(encoding=encoding, errors='ignore')
-
-    # return as content list, split at line breaks
-    decoded_content = decoded_content.split('\n')
-    return [('', line) for line in decoded_content]
```

## Comparing `cat_win/util/service/checksum.py` & `cat_win/src/service/checksum.py`

 * *Files identical despite different names*

## Comparing `cat_win/util/service/converter.py` & `cat_win/src/service/converter.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,46 +1,18 @@
 """
 converter
 """
 
-import re
+from cat_win.src.const.regex import RE_EVAL
 
 class Converter:
     """
     converts a binary, octal, decimal or hex number
     into the corresponding others, or evaluates an expression.
     """
-    # matches a mathematical expression consisting of
-    # either hex-numbers = (0x...), binary-numbers (0b...) or
-    # default decimal numbers
-    # (these are not allowed to have a leading zero
-    # before the decimal point, yet something like "-.06" is allowed).
-    # between every number has to be a valid operator (*,/,+,-,%,**,//)
-    # before every number there may be opening parenthesis,
-    # after every number there may be closing parenthesis
-    # (it is not validated that all parenthesis
-    # match each other to a valid expression ...)
-    _eval_regex = re.compile(
-        r'(?:\(\s*)*'
-        r'(?:'
-            r'(?:\-?0'
-                r'(?:'
-                    r'(?:x[0-9a-fA-F]+)'
-                    r'|(?:o[0-7]+)'
-                r'|b[01]+)'
-            r'|(?:\-?(?:(?:0|[1-9][0-9]*)\.[0-9]*|\.[0-9]+|0|[1-9][0-9]*)))'
-        r'[\)\s]*[%\-\/\+\*][\/\*]?[\(\s]*)+'
-        r'(?:\-?0'
-            r'(?:'
-                r'(?:x[0-9a-fA-F]+)'
-                r'|(?:o[0-7]+)'
-            r'|b[01]+)'
-        r'|(?:\-?(?:(?:0|[1-9][0-9]*)\.[0-9]*|\.[0-9]+|0|[1-9][0-9]*)))'
-        r'(?:\s*\))*'
-        )
 
     bindigits = '01'
     octdigits = '01234567'
     hexdigits = '0123456789abcdefABCDEF'
 
     def __init__(self) -> None:
         self.colors = ['', '', '']
@@ -87,15 +59,15 @@
             parts should stay within the line
             
         Returns:
         (str):
             the new content line with the evaluated expression
         """
         new_l_tokens = []
-        res = re.search(self._eval_regex, _l)
+        res = RE_EVAL.search(_l)
 
         while res:
             if integrated:
                 new_l_tokens.append(_l[:res.start()])
             try:
                 new_l_tokens.append(f"{self.colors[0]}{eval(res.group())}{self.colors[2]}")
             except SyntaxError as exc:
@@ -116,15 +88,15 @@
                     new_l_tokens.append(f"{self.colors[0]}" + \
                         f"{('?' * len(res.group()) if integrated else '?')}{self.colors[2]}")
                 except (NameError, ValueError, ArithmeticError) as exc_inner:
                     self._evaluate_exception_handler(exc_inner, res.group(), new_l_tokens)
             except (NameError, ValueError, ArithmeticError) as exc:
                 self._evaluate_exception_handler(exc, res.group(), new_l_tokens)
             _l = _l[res.end():]
-            res = re.search(self._eval_regex, _l)
+            res = RE_EVAL.search(_l)
 
         if integrated:
             new_l_tokens.append(_l)
 
         if not new_l_tokens:
             return '' if integrated else None
         return (',' * (not integrated)).join(new_l_tokens)
@@ -135,63 +107,63 @@
         v (str):
             the string to check
             
         Returns:
             True if v is a Hexadecimal number.
             False if it is not.
         """
-        if _v[:1] == '-':
+        if _v.startswith('-'):
             _v = _v[1:]
-        if _v[:2] == '0x':
+        if _v.startswith('0x'):
             _v = _v[2:]
         return all(c in self.hexdigits for c in _v) and _v != ''
 
     def is_dec(self, _v: str) -> bool:
         """
         Parameters:
         v (str):
             the string to check
             
         Returns:
             True if v is a Decimal number.
             False if it is not.
         """
-        if _v[:1] == '-':
+        if _v.startswith('-'):
             _v = _v[1:]
         return _v.isdecimal() and _v != ''
 
     def is_oct(self, _v: str) -> bool:
         """
         Parameters:
         v (str):
             the string to check
             
         Returns:
             True if v is a Octal number.
             False if it is not.
         """
-        if _v[:1] == '-':
+        if _v.startswith('-'):
             _v = _v[1:]
-        if _v[:2] == '0o':
+        if _v.startswith('0o'):
             _v = _v[2:]
         return all(c in self.octdigits for c in _v) and _v != ''
 
     def is_bin(self, _v: str) -> bool:
         """
         Parameters:
         v (str):
             the string to check
             
         Returns:
             True if v is a Binary number.
             False if it is not.
         """
-        if _v[:1] == '-':
+        if _v.startswith('-'):
             _v = _v[1:]
-        if _v[:2] == '0b':
+        if _v.startswith('0b'):
             _v = _v[2:]
         return all(c in self.bindigits for c in set(_v)) and _v != ''
 
 
     def __hex_to_dec__(self, value: str) -> str:
         return str(int(value, 16))
```

## Comparing `cat_win/util/service/editor.py` & `cat_win/src/service/editor.py`

 * *Files 3% similar despite different names*

```diff
@@ -20,38 +20,18 @@
     CURSES_MODULE_ERROR = False
 except ImportError:
     CURSES_MODULE_ERROR = True
 import os
 import signal
 import sys
 
-from cat_win.util.helper.editorhelper import History, Position, UNIFY_HOTKEYS, \
+from cat_win.src.service.helper.editorhelper import History, Position, UNIFY_HOTKEYS, \
     KEY_HOTKEYS, ACTION_HOTKEYS, SCROLL_HOTKEYS
-from cat_win.util.service.rawviewer import SPECIAL_CHARS
-
-def get_newline(file: str) -> str:
-    """
-    determines the line ending of a given file.
-    
-    Parameters:
-    file (str):
-        a file (-path) as string representation
-        
-    Returns:
-    (str):
-        the line ending that the given file is using
-        (\r or \n or \r\n)
-    """
-    try:
-        with open(file, 'rb') as _f:
-            _l = _f.readline()
-            _l += b'\n' * bool(not _l[-1:] or _l[-1:] not in b'\r\n')
-            return '\r\n' if _l[-2:] == b'\r\n' else _l[-1:].decode()
-    except OSError:
-        return '\n'
+from cat_win.src.service.helper.iohelper import IoHelper, err_print
+from cat_win.src.service.rawviewer import SPECIAL_CHARS
 
 
 class Editor:
     """
     Editor
     """
     loading_failed = False
@@ -106,25 +86,27 @@
             return self.special_chars[char]
         return '?'
 
     def _setup_file(self) -> None:
         """
         setup the editor content screen by reading the given file.
         """
+        self.window_content = []
         try:
-            self.line_sep = get_newline(self.file)
-            self.window_content = []
-            with open(self.file, 'r', encoding=self.file_encoding) as _f:
-                for line in _f.read().split('\n'):
-                    self.window_content.append(line)
+            self.line_sep = IoHelper.get_newline(self.file)
+            _f_content = IoHelper.read_file(self.file, file_encoding=self.file_encoding)
+            for line in _f_content.split('\n'):
+                self.window_content.append(line)
         except (OSError, UnicodeError) as exc:
             self.window_content.append('')
+            self.unsaved_progress = True
             self.status_bar_size = 2
             self.error_bar = str(exc)
-            self.unsaved_progress = True
+            if self.debug_mode:
+                err_print(self.error_bar)
 
     def getxymax(self) -> tuple:
         """
         find the size of the window.
         
         Returns:
         (tuple):
@@ -429,25 +411,25 @@
         Returns
         (bool):
             indicates if the editor should keep running
         """
         content = self.line_sep.join(self.window_content)
         try:
             # encode here to potentially trigger the unicodeerror event
-            write_func(content.encode(self.file_encoding), self.file, self.file_encoding)
+            write_func(self.file, content.encode(self.file_encoding), self.file_encoding)
             self.changes_made = True
             self.unsaved_progress = False
             self.error_bar = ''
             self.status_bar_size = 1
         except (OSError, UnicodeError) as exc:
             self.unsaved_progress = True
-            self.error_bar = str(exc)
             self.status_bar_size = 2
+            self.error_bar = str(exc)
             if self.debug_mode:
-                print(self.error_bar, file=sys.stderr)
+                err_print(self.error_bar)
         return True
 
     def _action_jump(self, _) -> bool:
         """
         handles the jump to line action.
         
         Parameters:
@@ -617,15 +599,15 @@
         handles the interrupt action.
         
         Returns:
         (bool):
             indicates if the editor should keep running
         """
         if self.debug_mode:
-            print('Interrupting...', file=sys.stderr)
+            err_print('Interrupting...')
         raise KeyboardInterrupt
 
     def _action_resize(self, _) -> bool:
         """
         handles the resizing of the (terminal) window.
         
         Returns:
@@ -647,16 +629,16 @@
         (tuple):
             the char received and the possible action it means.
         """
         def debug_out(wchar_, key__, key_) -> None:
             if self.debug_mode:
                 _debug_info = repr(chr(wchar_)) if isinstance(wchar_, int) else \
                     ord(wchar_) if len(wchar_) == 1 else '-'
-                print(f"__DEBUG__: Received  {key_}\t{_debug_info}" + \
-                    f"\t{str(key__):<15} \t{repr(wchar_)}", file=sys.stderr)
+                err_print(f"__DEBUG__: Received  {key_}\t{_debug_info}" + \
+                    f"\t{str(key__):<15} \t{repr(wchar_)}")
         buffer: tuple = None
         while True:
             if buffer is not None:
                 key = UNIFY_HOTKEYS.get(buffer[1], b'_key_string')
                 debug_out(*buffer, key)
                 yield (buffer[0], key)
                 buffer = None
@@ -819,15 +801,15 @@
 
                     # handle new wchar
                     if key in KEY_HOTKEYS:
                         f_len = len(self.window_content)
                         pre_pos = self.cpos.get_pos()
                         action_text = getattr(self, key.decode(), lambda *_: None)(wchar)
                         self.history.add(key, action_text, f_len, pre_pos, self.cpos.get_pos())
-                        if key == b'_key_enter':
+                        if Editor.auto_indent and key == b'_key_enter':
                             indent_offset = 0
                             while self.window_content[self.cpos.row-1][indent_offset:].startswith(
                                 self.special_indentation):
                                 f_len = len(self.window_content)
                                 pre_pos = self.cpos.get_pos()
                                 action_text = self._key_string(self.special_indentation)
                                 self.history.add(b'_key_string', action_text, f_len,
@@ -915,33 +897,33 @@
         
         Parameters:
         file (str):
             a string representing a file(-path)
         display_name (str):
             the display name for the current file
         write_func (method):
-            stdinhelper.write_file [simply writes a file]
+            iohelper.write_file [simply writes a file]
         on_windows_os (bool):
             indicates if the user is on windows OS using platform.system() == 'Windows'
         skip_binary (bool):
             indicates if the Editor should skip non-plaintext files
         
         Returns:
         (bool):
             indicates whether or not the editor has written any content to the provided files
         """
         if Editor.loading_failed:
             return False
 
         if CURSES_MODULE_ERROR:
-            print("The Editor could not be loaded. No Module 'curses' was found.", file=sys.stderr)
+            err_print("The Editor could not be loaded. No Module 'curses' was found.")
             if on_windows_os:
-                print('If you are on Windows OS, try pip-installing ', end='', file=sys.stderr)
-                print("'windows-curses'.", file=sys.stderr)
-            print(file=sys.stderr)
+                err_print('If you are on Windows OS, try pip-installing ', end='')
+                err_print("'windows-curses'.")
+            err_print()
             Editor.loading_failed = True
             return False
 
         editor = cls(file, display_name)
         if skip_binary and editor.error_bar:
             return False
         special_chars = dict(map(lambda x: (chr(x[0]), x[2]), SPECIAL_CHARS))
```

## Comparing `cat_win/util/service/fileattributes.py` & `cat_win/src/service/fileattributes.py`

 * *Files 1% similar despite different names*

```diff
@@ -11,15 +11,15 @@
     FILE_ATTRIBUTE_NOT_CONTENT_INDEXED as I,
     FILE_ATTRIBUTE_COMPRESSED as C,
     FILE_ATTRIBUTE_ENCRYPTED as E
 )
 import math
 import os
 
-from cat_win.util.helper.winstreams import WinStreams
+from cat_win.src.service.helper.winstreams import WinStreams
 
 
 def _convert_size(size_bytes: int) -> str:
     """
     convert a size value to a more compact representation
     
     Parameters_
```

## Comparing `cat_win/util/service/formatter.py` & `cat_win/src/service/formatter.py`

 * *Files identical despite different names*

## Comparing `cat_win/util/service/more.py` & `cat_win/src/service/more.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 """
 more
 """
 
 import os
 import sys
 
-from cat_win.util.helper import stdinhelper
+from cat_win.src.service.helper.iohelper import IoHelper
 
 
 class More:
     """
     implements 'more' behaviour
     """
     on_windows_os = True
@@ -210,9 +210,9 @@
         dup_needed (bool):
             indicates if the stdin-dup is needed
         """
         if not os.isatty(sys.stdout.fileno()):
             print(*self.lines, sep='\n')
             return
 
-        with stdinhelper.dup_stdin(More.on_windows_os, dup_needed):
+        with IoHelper.dup_stdin(More.on_windows_os, dup_needed):
             self._step_through()
```

## Comparing `cat_win/util/service/rawviewer.py` & `cat_win/src/service/rawviewer.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,14 @@
 """
 rawviewer
 """
 
+from cat_win.src.service.helper.iohelper import IoHelper
+
+
 SPECIAL_CHARS = [
     ( 0, 'NUL', '␀', True), # ^@ \0 null
     # ( 1, 'SOH', '␁', False), # ^A start of heading
     # ( 2, 'STX', '␂', False), # ^B start of text
     # ( 3, 'ETX', '␃', False), # ^C end of text
     ( 4, 'EOT', '␄', True), # ^D end of transmission
     # ( 5, 'ENQ', '␅', False), # ^E enquiry
@@ -82,17 +85,16 @@
         if 32 <= byte <= 126:
             return chr(byte)
         if byte in special_chars.keys():
             return special_chars[byte]
         return special_chars[-1]
 
     try:
-        with open(file, 'rb') as raw_file:
-            raw_file_content = raw_file.read()
-            raw_file_content_length = len(raw_file_content)
+        raw_file_content = IoHelper.read_file(file, True)
+        raw_file_content_length = len(raw_file_content)
     except OSError as exc:
         yield type(exc).__name__
         return ''
 
     repr_length = 2 * (mode.upper() == 'X') + 8 * (mode == 'b')
 
     current_line = f"{colors[0]}Address  "
```

## Comparing `cat_win/util/service/stringfinder.py` & `cat_win/src/service/stringfinder.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,12 @@
 """
 stringfinder
 """
 
-import re
-
-from cat_win.const.colorconstants import CKW
+from cat_win.src.const.colorconstants import CKW
 
 
 class StringFinder:
     """
     defines a stringfinder
     """
     def __init__(self, literals: set = None, regex: set = None) -> None:
@@ -33,30 +31,29 @@
             sub, _s = sub.lower(), _s.lower()
         _l = len(sub)
         i = _s.find(sub)
         while i != -1:
             yield [i, i+_l]
             i = _s.find(sub, i+1)
 
-    def _findregex(self, pattern: str, _s: str, ignore_case: bool):
+    def _findregex(self, pattern, _s: str):
         """
         Generate lists containing the position of pattern in s.
         
         Parameters:
-        pattern (str):
+        pattern (re_pattern):
             the regex pattern to search for
         s (str):
             the string to search in
         
         Yields:
         (list):
             containing the start and end indeces like [start, end]
         """
-        for _match in re.finditer(pattern, _s,
-                                 re.IGNORECASE if ignore_case else 0 | re.DOTALL):
+        for _match in pattern.finditer(_s):
             yield list(_match.span())
 
     def _optimize_intervals(self, intervals: list) -> list:
         """
         optimize/shorten/merge overlapping intervalls for partially
         color encoded lines. Needed when multiple
         search-keywords apply to the same line.
@@ -118,17 +115,17 @@
         for keyword, ignore_case in self.kw_literals:
             for _f in self._findliterals(keyword, line, ignore_case):
                 found_position.append(_f[:])
                 found_list.append((keyword, _f))
         # sort by start position (necessary for a deterministic output)
         found_list.sort(key = lambda x: x[1][0])
 
-        for keyword, ignore_case in self.kw_regex:
-            for _m in self._findregex(keyword, line, ignore_case):
+        for pattern in self.kw_regex:
+            for _m in self._findregex(pattern, line):
                 matched_position.append(_m[:])
-                matched_list.append((keyword, _m))
+                matched_list.append((pattern.pattern, _m))
         # sort by start position (necessary for a deterministic output)
         matched_list.sort(key = lambda x: x[1][0])
 
         return (self._merge_keyword_intervals(found_position, matched_position),
                 found_list,
                 matched_list)
```

## Comparing `cat_win/util/service/strings.py` & `cat_win/src/service/strings.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,18 +14,20 @@
     delim (str):
         the delimeter to display the found strings on the same line
     
     Returns:
     new_content (list):
         the new file content containing all found strings [('', string), ...]
     """
+    content_type_raw = bool(content) and isinstance(content[0][1], bytes)
     new_content = []
-    min_seq_len = max(min_seq_len, 1)
     new_string = ''
     for _, line in content:
+        if content_type_raw:
+            line = line.decode(errors='replace')
         new_line = []
         for char in line:
             if 32 <= ord(char) <= 126: # if it is printable ascii
                 new_string += char
                 continue
             if len(new_string) >= min_seq_len:
                 new_line.append(new_string)
```

## Comparing `cat_win/util/service/summary.py` & `cat_win/src/service/summary.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 """
 summary
 """
 
 from itertools import groupby
-import re
 
-from cat_win.util.service.fileattributes import get_file_size, _convert_size
+from cat_win.src.const.regex import TOKENIZER
+from cat_win.src.service.fileattributes import get_file_size, _convert_size
+from cat_win.src.service.helper.iohelper import IoHelper
 
 
 class Summary:
     """
     collection of static summaries.
     """
     color: str = ''
@@ -30,15 +31,15 @@
         Summary.color = color
         Summary.color_reset = color_reset
 
 
     @staticmethod
     def show_files(detailed: bool, files: list) -> None:
         """
-        displays holder.files including their size and calculates
+        displays u_files.files including their size and calculates
         their size sum.
         
         Parameters:
         detailed (bool):
             indicates if the detailed summary should be displayed.
         files (list):
             the fies to summarize.
@@ -97,30 +98,30 @@
         display the line sum of each file individually if
         detailed is specified.
         display the line sum of all files.
 
         detailed (bool):
             indicates if the detailed summary should be displayed.
         all_files_lines (dict):
-            the sum of lines for each file individually (see holder)
+            the sum of lines for each file individually (see files)
         all_line_number_place_holder (int):
             the amount of chars neccessary to display the last line (breaks on base64 decoding)
-            (see holder)
+            (see files)
         all_files_lines_sum (int):
-            the sum of all lines of all files (see holder)
+            the sum of all lines of all files (see files)
         """
         if detailed:
             longest_file_name = max(map(len, all_files_lines.keys())) + 1
             print(f"{Summary.color}{'File': <{longest_file_name}}{Summary.color_reset}"
                 f"{Summary.color}LineCount{Summary.color_reset}")
             for file, _ in all_files_lines.items():
                 print(f"{Summary.color}{file: <{longest_file_name}}" + \
                     f"{all_files_lines[file]: >{all_line_number_place_holder}}" + \
                         f"{Summary.color_reset}")
-            print('')
+            print()
         print(f"{Summary.color}Lines (Sum): " + \
             f"{all_files_lines_sum}{Summary.color_reset}")
 
     @staticmethod
     def show_wordcount(files: list, file_encoding: str) -> None:
         """
         summarize how often each word/token is used in the specifed files.
@@ -132,17 +133,17 @@
             the encoding to use when opening the files
         """
         word_count = {}
         used_files = []
 
         for hfile in files:
             try:
-                with open(hfile.path, 'r', encoding=file_encoding) as file:
-                    for token in re.findall(r'\w+|[^\s\w]', file.read()):
-                        word_count[token] = word_count.get(token, 0)+1
+                f_content = IoHelper.read_file(hfile.path, file_encoding=file_encoding)
+                for token in TOKENIZER.findall(f_content):
+                    word_count[token] = word_count.get(token, 0)+1
                 used_files.append(hfile.displayname)
             except (OSError, UnicodeError):
                 pass
         if not used_files:
             print(Summary.color, end='')
             print('The word count could not be calculated.', end='')
             print(Summary.color_reset)
@@ -178,17 +179,17 @@
             the encoding to use when opening the files
         """
         char_count = {}
         used_files = []
 
         for hfile in files:
             try:
-                with open(hfile.path, 'r', encoding=file_encoding) as file:
-                    for char in list(file.read()):
-                        char_count[char] = char_count.get(char, 0)+1
+                f_content = IoHelper.read_file(hfile.path, file_encoding=file_encoding)
+                for char in list(f_content):
+                    char_count[char] = char_count.get(char, 0)+1
                 used_files.append(hfile.displayname)
             except (OSError, UnicodeError):
                 pass
         if not used_files:
             print(Summary.color, end='')
             print('The char count could not be calculated.', end='')
             print(Summary.color_reset)
```

## Comparing `cat_win/web/updatechecker.py` & `cat_win/src/web/updatechecker.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,16 @@
 """
 
 import json
 import os
 import sys
 import urllib.request
 
-from cat_win.const.colorconstants import CKW
+from cat_win.src.const.colorconstants import CKW
+from cat_win.src.service.helper.iohelper import err_print
 from cat_win import __url__
 
 
 # UNSAFE:
 # UPDATE MAY INCLUDE FUNDAMENTAL CHANGES
 # recognized by a higher version number in earlier position
 # !.!._
@@ -196,9 +197,9 @@
         warning += 'You may experience fundamental differences.'
         warning += f"{color_dic[CKW.RESET_ALL]}"
     info += f"{color_dic[CKW.MESSAGE_INFORMATION]}Take a look at the changelog here:"
     info += f"{color_dic[CKW.RESET_ALL]}\n{color_dic[CKW.MESSAGE_INFORMATION]}"
     info += f"{__url__}/blob/main/CHANGELOG.md{color_dic[CKW.RESET_ALL]}"
 
     print(message)
-    print(warning, file=sys.stderr)
+    err_print(warning)
     print(info)
```

## Comparing `cat_win/web/urls.py` & `cat_win/src/web/urls.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,23 +1,17 @@
 """
 urls
 """
 
-import re
 import urllib.request
 import urllib.parse
 
+from cat_win.src.const.regex import DJANGO_VALID_URL_PATTERN
+
 DEFAULT_SCHEME = 'https://'
-DJANGO_VALID_URL_PATTERN = re.compile(
-    r'^(?:http|ftp)s?://' # http:// or https://
-    r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
-    r'localhost|' #localhost...
-    r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
-    r'(?::\d+)?' # optional port
-    r'(?:/?|[/?]\S+)$', re.IGNORECASE)
 
 
 def is_valid_uri(s_url: str, _rec: bool = False) -> bool:
     """
     check if a string is a valid uri, by matching the general pattern,
     aswell as parsing it.
     
@@ -30,15 +24,15 @@
     Returns:
     (bool):
         indicates whether or not the url is valid
     """
     try:
         parse_result = urllib.parse.urlparse(s_url)
         p_result = all([parse_result.scheme, parse_result.netloc])
-        r_result = re.match(DJANGO_VALID_URL_PATTERN, s_url) is not None
+        r_result = DJANGO_VALID_URL_PATTERN.match(s_url) is not None
         valid = r_result and p_result
         if not (valid or _rec):
             return is_valid_uri(DEFAULT_SCHEME+s_url, True)
         return valid
     except ValueError:
         return False
```

## Comparing `cat_win-1.7.5.dist-info/LICENSE` & `cat_win-1.7.6.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `cat_win-1.7.5.dist-info/METADATA` & `cat_win-1.7.6.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: cat_win
-Version: 1.7.5
+Version: 1.7.6
 Summary: Simple OS Independent 'cat' Command-line Tool made in Python.
 Keywords: cat,cli,console,crossplatform,python,terminal
 Author-email: "Silas A. Kraume" <silas.kraume1552@gmail.com>
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python
@@ -34,15 +34,15 @@
 <div id="top"></div>
 
 <p>
    <a href="https://pepy.tech/project/cat-win/" alt="Downloads">
       <img src="https://static.pepy.tech/personalized-badge/cat-win?period=total&units=international_system&left_color=grey&right_color=blue&left_text=Downloads" align="right">
    </a>
    <a href="https://pypi.org/project/cat-win/" alt="Visitors">
-      <img src="https://visitor-badge.laobi.icu/badge?page_id=SilenZcience.cat_win&right_color=orange" align="right">
+      <img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgithub.com%2FSilenZcience%2Fcat_win&count_bg=%23FF7700&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=Visitors&edge_flat=false" align="right">
    </a>
    <a href="https://github.com/SilenZcience/cat_win/tree/main/cat_win" alt="CodeSize">
       <img src="https://img.shields.io/github/languages/code-size/SilenZcience/cat_win?color=purple" align="right">
    </a>
 </p>
 
 [![OS-Windows]][OS-Windows]
```

### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: cat_win Version: 1.7.5 Summary: Simple OS
+Metadata-Version: 2.1 Name: cat_win Version: 1.7.6 Summary: Simple OS
 Independent 'cat' Command-line Tool made in Python. Keywords:
 cat,cli,console,crossplatform,python,terminal Author-email: "Silas A. Kraume"
 gmail.com> Requires-Python: >=3.7 Description-Content-Type: text/markdown
 Classifier: License :: OSI Approved :: MIT License Classifier: Programming
 Language :: Python Classifier: Programming Language :: Python :: 3 Classifier:
 Programming Language :: Python :: 3.7 Classifier: Programming Language ::
 Python :: 3.8 Classifier: Programming Language :: Python :: 3.9 Classifier:
@@ -20,17 +20,18 @@
 github.com/SilenZcience/cat_win/blob/main/ARGUMENTS.md#cat_win Project-URL:
 Download, https://github.com/SilenZcience/cat_win/tarball/master Project-URL:
 Github, https://github.com/SilenZcience/cat_win Project-URL: Issues, https://
 github.com/SilenZcience/cat_win/issues Provides-Extra: cfix Provides-Extra:
 clip
 _[_h_t_t_p_s_:_/_/_s_t_a_t_i_c_._p_e_p_y_._t_e_c_h_/_p_e_r_s_o_n_a_l_i_z_e_d_-_b_a_d_g_e_/_c_a_t_-
 _w_i_n_?_p_e_r_i_o_d_=_t_o_t_a_l_&_u_n_i_t_s_=_i_n_t_e_r_n_a_t_i_o_n_a_l___s_y_s_t_e_m_&_l_e_f_t___c_o_l_o_r_=_g_r_e_y_&_r_i_g_h_t___c_o_l_o_r_=_b_l_u_e_&_l_e_f_t___t_e_x_t_=_D_o_w_n_l_o_a_d_s_]
-_[_h_t_t_p_s_:_/_/_v_i_s_i_t_o_r_-_b_a_d_g_e_._l_a_o_b_i_._i_c_u_/
-_b_a_d_g_e_?_p_a_g_e___i_d_=_S_i_l_e_n_Z_c_i_e_n_c_e_._c_a_t___w_i_n_&_r_i_g_h_t___c_o_l_o_r_=_o_r_a_n_g_e_]_[_h_t_t_p_s_:_/_/_i_m_g_._s_h_i_e_l_d_s_._i_o_/
-_g_i_t_h_u_b_/_l_a_n_g_u_a_g_e_s_/_c_o_d_e_-_s_i_z_e_/_S_i_l_e_n_Z_c_i_e_n_c_e_/_c_a_t___w_i_n_?_c_o_l_o_r_=_p_u_r_p_l_e_]
+_[_h_t_t_p_s_:_/_/_h_i_t_s_._s_e_e_y_o_u_f_a_r_m_._c_o_m_/_a_p_i_/_c_o_u_n_t_/_i_n_c_r_/
+_b_a_d_g_e_._s_v_g_?_u_r_l_=_h_t_t_p_s_%_3_A_%_2_F_%_2_F_g_i_t_h_u_b_._c_o_m_%_2_F_S_i_l_e_n_Z_c_i_e_n_c_e_%_2_F_c_a_t___w_i_n_&_c_o_u_n_t___b_g_=_%_2_3_F_F_7_7_0_0_&_t_i_t_l_e___b_g_=_%_2_3_5_5_5_5_5_5_&_i_c_o_n_=_&_i_c_o_n___c_o_l_o_r_=_%_2_3_E_7_E_7_E_7_&_t_i_t_l_e_=_V_i_s_i_t_o_r_s_&_e_d_g_e___f_l_a_t_=_f_a_l_s_e_]
+_[_h_t_t_p_s_:_/_/_i_m_g_._s_h_i_e_l_d_s_._i_o_/_g_i_t_h_u_b_/_l_a_n_g_u_a_g_e_s_/_c_o_d_e_-_s_i_z_e_/_S_i_l_e_n_Z_c_i_e_n_c_e_/
+_c_a_t___w_i_n_?_c_o_l_o_r_=_p_u_r_p_l_e_]
 [![OS-Windows]][OS-Windows] [![OS-Linux]][OS-Linux] [![OS-MacOS]][OS-MacOS]
                               ********** ccaatt__wwiinn **********
                    Simple Command-line Tool made in Python
                              _EE_xx_pp_ll_oo_rr_ee_ _tt_hh_ee_ _cc_oo_dd_ee_ _?Â_?»_ 
 
                          _R_e_p_o_r_t_ _B_u_g Â· _R_e_q_u_e_s_t_ _F_e_a_t_u_r_e
 Table of Contents
```

## Comparing `cat_win-1.7.5.dist-info/RECORD` & `cat_win-1.7.6.dist-info/RECORD`

 * *Files 22% similar despite different names*

```diff
@@ -1,50 +1,88 @@
-cat_win/__init__.py,sha256=480MPOcgEMYDLanwDm5MVX14tJJzFXABm2YFyWHUcCM,305
-cat_win/__main__.py,sha256=qBGZLDqzopf9KAzfZpE8HoNa4qKnE2joLqTmzcm6O4M,483
-cat_win/cat.py,sha256=cwZ1yWzpCLrTBriRMbI98dV6Fbf5rivafGjqcncTR7w,52923
-cat_win/shell.py,sha256=6tNGZADiiUYfDXGLfCjTdCLTPmOQ1KJnetahi_Jx518,391
-cat_win/const/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cat_win/const/argconstants.py,sha256=u7pT2_bM71dGsT561JGsJ_uKcx_dn4HP5pjhapMJ_RU,8829
-cat_win/const/colorconstants.py,sha256=7uthARD7EyKMkIFirOOamQD_Ec1pgtUi4ESJWvoVx2s,2661
-cat_win/const/defaultconstants.py,sha256=WgXct6Pu6koNlTqfmUyQedBHdmIUloyS2yLdlb3NfhI,711
-cat_win/persistence/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cat_win/persistence/cconfig.py,sha256=4OpzxWQzmbvIEYtSPKQiKT4YzGuv4OYO20v_cDI7srw,10585
-cat_win/persistence/config.py,sha256=poZblbGy1jV3jC7kx0l3KMlPy9zeeTV7aVM45RrvT1I,9773
+cat_win/__init__.py,sha256=0Pxms3fSQWzNZv2J9BpN1TY9-iVDQ60NabN9A3UPf94,305
+cat_win/__main__.py,sha256=v41ByZlqmG9uDhcWVrNiwsI2PgKMwn77svYOpU9FXko,487
+cat_win/shell.py,sha256=mhDLWhAgxbIMGqHicSDEMm2CuPTBMBSGdTpzwLTuNAo,395
+cat_win/src/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/src/argparser.py,sha256=j99CE3UhgA67dkzSIwM220WzbC_kS1AWqk-5rLzZbhs,12543
+cat_win/src/cat.py,sha256=u3FIwDC2gv9bpgWLCyrZfxDIoqgQaacGp-xzqnxQrXw,51723
+cat_win/src/const/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/src/const/argconstants.py,sha256=wGgnUdQyLk5910dEX18vbkyCp7fnMfo4EfOvQ0fNJwA,9430
+cat_win/src/const/colorconstants.py,sha256=7uthARD7EyKMkIFirOOamQD_Ec1pgtUi4ESJWvoVx2s,2661
+cat_win/src/const/defaultconstants.py,sha256=Wq0ux8Gx3kMOafDZAejP9OwRFCr6CcypefTM60EQRCQ,740
+cat_win/src/const/regex.py,sha256=k622G-yOnYxVbzUt_Bg2dSyHGCBEuFBKCpzDivBMDFk,2583
+cat_win/src/domain/arguments.py,sha256=FhxaHlgRlyag4lD7aa6ie6dlp9EMGzEk_jasLRiHVXA,3289
+cat_win/src/domain/file.py,sha256=SIZJQb0N1rKNSMXjL6CGyy-wVTFtes33GM6LhUL_Des,824
+cat_win/src/domain/files.py,sha256=pp5EcQVspDZ1abY_sVy5mW0prlROoyciwIxVMqxB4NQ,5420
+cat_win/src/persistence/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/src/persistence/cconfig.py,sha256=xaIPMzZyBe_M0Fu98d7keE4BoLu5O78H-YH2cN8JFaQ,11316
+cat_win/src/persistence/config.py,sha256=E3zETk-wPnTWLjMLczNTtuz3We-58cFxbN4wyo-0WtM,10976
+cat_win/src/service/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/src/service/cbase64.py,sha256=oyN2DejzBwcboweJvgkbmIWUCgamsDNDL82M7y0ea6E,2193
+cat_win/src/service/checksum.py,sha256=ahCkzIFUdqAyeZHAzFCJ__WXpbHa3R4urZfFIKDNot0,2193
+cat_win/src/service/clipboard.py,sha256=gjKL2d1pjcBjgCBiK_hARCEWK7eP3vsi8Du3ci4sRvE,2370
+cat_win/src/service/converter.py,sha256=jOlJwHKXDWqCCMl6bF48RYWJIiWQrMeHCMPXsCbT7jE,8872
+cat_win/src/service/editor.py,sha256=QmQ3F4YIQmlxtu38-O5eGkE4o38Bf11CVr2j46j027o,38209
+cat_win/src/service/fileattributes.py,sha256=0tU5GcS6pU26X5Yi4fgiSg6xSHm3g5zt4kgCBXPHrsU,5103
+cat_win/src/service/formatter.py,sha256=3_QqdATMKxjPbFuC4nGDZzA2duFToC2LPpjo0mhCYrk,2141
+cat_win/src/service/more.py,sha256=4c3n7nxpnS14O_bnyk8K6CVVekufd1YbxYmZ9-9TJ_A,8486
+cat_win/src/service/rawviewer.py,sha256=WezPI9j7JdiYAs9Ix1V75-E_VhYz8ORoWNnWABuo6zA,4922
+cat_win/src/service/stringfinder.py,sha256=2Zz3w1bBJvbJx2uZIesjl1-wKzyJKEsNkimaLx-1UK8,4290
+cat_win/src/service/strings.py,sha256=qgKIslOlstYip9L6ZilHAWDRkn8vfkKw0KlvDoqfhYQ,1295
+cat_win/src/service/summary.py,sha256=1mvQcvi1rHwIJKoQZZXrw5aQAVzYF2XWDg96UHqzEHQ,8242
+cat_win/src/service/helper/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/src/service/helper/editorhelper.py,sha256=n_4AwjL9h-JwdTR_W2YFTEm5IZSQzf-hShC6f7lbCho,13795
+cat_win/src/service/helper/iohelper.py,sha256=6QGK6bOB7xRcH1H108gDUZ7xhudw1rjVatmpqNerDEw,11311
+cat_win/src/service/helper/tmpfilehelper.py,sha256=t2ZBKJTAnBDHDrU-Y2bt4YbRpHEdpjDkyVVNVZ6o0Ss,703
+cat_win/src/service/helper/utility.py,sha256=ZyB0eebceqnuZc4yfc_cetd906d0gMT-D-6l8vdk_Kk,2001
+cat_win/src/service/helper/utilityold.py,sha256=HQ6FzpKgivbgzxhlDsp25o__vNK51ywB52EpjalpqJg,2171
+cat_win/src/service/helper/winstreams.py,sha256=jnmgySnvuJ6oEqkYSyei_Y-YfyDRlHeFK69CeANNyEc,1942
+cat_win/src/service/helper/zipviewer.py,sha256=kJs0E3fZhQ9Q2pEtBuqkWuLtYG7cxxnv8e7XPwcdFyA,1406
+cat_win/src/web/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/src/web/updatechecker.py,sha256=CO80lYsrXwbdRf87FyXWCrMXXXXlJngChOosBf-qADQ,6882
+cat_win/src/web/urls.py,sha256=2WOh4r3U42HyfM1r0IHYgC9eCwM7k5o0-ffJl1Ei_b0,2224
 cat_win/tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cat_win/tests/test_ansi.py,sha256=UekkO7n2fEvS5Lmn0umO5QF02LMGDk50lfeZC_NsdNg,4492
-cat_win/tests/test_argconstants.py,sha256=LLXFOo6XBX16ppdiTA8f_IfQEmglR7QtL4xQZAnYCeY,1187
-cat_win/tests/test_argparser.py,sha256=A_-vh0n-rPl0b_Og5R2fbXpew0X_78GNtpkhPYS5jK4,12486
-cat_win/tests/test_cat.py,sha256=LZ60bBYYBECu3QIeK29DttkP8scNysx7PxQuFUXnYng,8978
-cat_win/tests/test_cbase64.py,sha256=8FmEoJzHjnHVnqN-jOnGHjTU30CuuAIV55tFXToHgZo,1139
-cat_win/tests/test_cconfig.py,sha256=ku4vvPlAAXpaNvgDmyS46xkqUUPfJyH9ySlerU7LcoM,1564
-cat_win/tests/test_checksum.py,sha256=NO4jVsmv2F4lvx-N4cz2qxnIywer_wPYBF8VGcM3Jzg,1763
-cat_win/tests/test_config.py,sha256=9fqfbgVXKwhFlPkPAq_eNI1ybdKr3HXIOmzbRFh4sDE,3293
-cat_win/tests/test_converter.py,sha256=dK9him6QhhfR1qtnvqUsMag8yG4q7OODkoZSPQhEBSc,5724
-cat_win/tests/test_editor.py,sha256=iHKsTOW7-DQziAy2WUdZ4nFL32t5ASKRxbqDuL8xKxw,18785
-cat_win/tests/test_file.py,sha256=p7KANJdj76-Uct5YjCmAEryjJIOR8hDeO1si-uvLItU,1047
-cat_win/tests/test_fileattributes.py,sha256=RdZN1pfaFw7woUlNlZVl5x-GYi8hINlVuEagIPLaZdc,2084
-cat_win/tests/test_full.py,sha256=OMa0g4jR0zJVKV4-4TPqZ2kKJKDTFYkrrsbrHgK24bY,11109
-cat_win/tests/test_holder.py,sha256=_-rF6FBB63pTaJmXT6269APGulMf_GmCb849g5dAt30,7608
-cat_win/tests/test_more.py,sha256=SxGHVRsZScGQ5exGx8q73GL9SKE5mbQpc5UtmMblXyk,6397
-cat_win/tests/test_rawviewer.py,sha256=cuB9sNzR7Ja5NHIF2JVIzhGfd3UVmUa0xtXp57VS7SM,7461
-cat_win/tests/test_shell.py,sha256=bjxPRS-hDQj8cofFSbvRQuuWSFQIMFCTPCgIeTqGqlU,5622
-cat_win/tests/test_stdinhelper.py,sha256=og1iXJVtX14MtPsZ_6tw2lxTh3IRvDURxb3OuyWyYv0,1240
-cat_win/tests/test_stringfinder.py,sha256=3aNOzASsja9VLy-kJrh8-mw6gyeoAORwXQYfY9teoCY,3448
-cat_win/tests/test_strings.py,sha256=blslsggL3voVp_50BkDNnmt8G1YkEzkjA_s_rQPpdkI,2374
-cat_win/tests/test_summary.py,sha256=7NM5tGb9tPLxgx2drQPvEaClK95VIezIxRrtXd3ZoRM,2372
-cat_win/tests/test_updatechecker.py,sha256=aqYS4y3ZBppH865UBPj7GJwvNHKbeclWqg_RqSsnUkc,4212
-cat_win/tests/test_urls.py,sha256=iOhxF6T6jx9k5Qrvx7YqpUuEnJ-f3MhgMlkLxfn9U0g,1699
-cat_win/tests/test_utility.py,sha256=MBm-GSVZobKUXgnL09tRambzC0P0y4s_Bvk390bW20E,5874
-cat_win/tests/test_zipviewer.py,sha256=r3SEOPo1Ze4JaLNtIM1kCznxGUBF5y81xk_V2AQ6e2I,1519
 cat_win/tests/mocks/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cat_win/tests/mocks/edit.py,sha256=x8vZvKwnUg9tzmj925Bjzx5StyfHZMVTY0WlqFJstaE,74
 cat_win/tests/mocks/error.py,sha256=XX3aFpagzFD5Dvx4Q0xfrdaXCg5QlsVBRimPgsW_8dw,330
 cat_win/tests/mocks/std.py,sha256=4TX9t2QA4_w6BcCSXcjCain45LLNcwYWEqgATOm4POw,3010
 cat_win/tests/resources/test.bin,sha256=buQNpRX6FybnzHwNLWEnaQ7bS3gCxgw9UQ4ibdGSYTc,15965
 cat_win/tests/resources/test.zip,sha256=m7LDNSiJjrZdQYdp8bylTSdzK19DF1irXot350meiDo,363
+cat_win/tests/src/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/tests/src/test_ansi.py,sha256=dNCtdJCR2fjWAzOEzrdPV3GgnzkWdUrg4qNzY08c7Y4,4568
+cat_win/tests/src/test_argparser.py,sha256=kTChj07aRbjPsXcD7XfI5DtCXc2QGiuDj-Rqmq4ByqQ,12675
+cat_win/tests/src/test_cat.py,sha256=t1DZL8dsAQYgOg8L9SgcEv5Z2K-A6GxAyUFie3W5ZcE,9048
+cat_win/tests/src/test_full.py,sha256=1lOLdAiox_xtJpCVRIp83f6vdYV3gxbx5sdaBz_Tpis,11179
+cat_win/tests/src/test_shell.py,sha256=so_Cflro0bmbXi3bqboEddIHwaIJl-SOxPXywEvK6ho,5798
+cat_win/tests/src/const/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/tests/src/const/test_argconstants.py,sha256=Kw88_EH2s4DLdQ1BSHTgG5d-QTaT-Z72OQdtfg7-70Q,1191
+cat_win/tests/src/domain/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/tests/src/domain/test_arguments.py,sha256=jc3CJo6RQOTOgqFNPLS7RQdFiiGMMKqgtVYwOkaePak,3418
+cat_win/tests/src/domain/test_file.py,sha256=g6ygmfoIRYljuWSnPKb7gwE_IdsYJ0uBRcn7cLj3Dnk,1046
+cat_win/tests/src/domain/test_files.py,sha256=XU9WHTV20A30wdWn3TbQEZIh0fao-ZwGX-tZOVdIJ3A,4413
+cat_win/tests/src/persistence/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/tests/src/persistence/test_cconfig.py,sha256=vFtYLR7OP0czEf371w0GnBfjW2rDSGh5H4AtVQwl5kw,1572
+cat_win/tests/src/persistence/test_config.py,sha256=E6uO-ot6z_6Aa_z4mWRlNS_1cd8Z7qGrsb6gPw6ZxoY,3301
+cat_win/tests/src/service/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/tests/src/service/test_cbase64.py,sha256=A6zMJKD0OLt7lkKNFpIoLAnAp44cxXlMl8S9d_oRigI,1953
+cat_win/tests/src/service/test_checksum.py,sha256=plSCyBCGUGwZKpfijC_AA6Ga92uDmtWq6_1T7XrMo1Q,1774
+cat_win/tests/src/service/test_converter.py,sha256=DJKDxKbsZIP9jabOKKaXpErTLU7TGyN6zPMmlgvaFC4,5723
+cat_win/tests/src/service/test_editor.py,sha256=VGSkbVdSNn_Gm-yC6QYokLW4Hv2e9Mnzr4ol8Nh25BM,18545
+cat_win/tests/src/service/test_fileattributes.py,sha256=-PmmPZ6-Is6RfElWMk4MBnHbm6ZDjPDmkpncrRu1ndc,2083
+cat_win/tests/src/service/test_more.py,sha256=l42nAZU9ANCRFSyfScKoVU00wJunpWITpfXjZM79WEE,6395
+cat_win/tests/src/service/test_rawviewer.py,sha256=5Df5xIrpIBZfszjpDBbs0g0pwf5E8AaOkua7cV009sY,7472
+cat_win/tests/src/service/test_stringfinder.py,sha256=uEXwnSYrtWm0qvYtPk4YIduIFuv644OxeYnEpmDmSJg,3816
+cat_win/tests/src/service/test_strings.py,sha256=Vo4eG4GdsRPTJJ4PkrUQmi33bGENbRFq2yaKvKJNQg8,2385
+cat_win/tests/src/service/test_summary.py,sha256=_O2c7rZAXt6dCczdboCn15f5FWTEH37tIVGQvCjkMt8,2382
+cat_win/tests/src/service/helper/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/tests/src/service/helper/test_iohelper.py,sha256=ipZdlWsNw2IiuhxOQ1OoqDpm9V3vlr_OX9q3uVhbsOI,1832
+cat_win/tests/src/service/helper/test_utility.py,sha256=mJ0NXyScFfxlr3PnIABOprOndnHWZyuNOhMXjIlvgLA,5895
+cat_win/tests/src/service/helper/test_zipviewer.py,sha256=UeRoOxvrD4y0ukz6l-sOqxzDfLR3b5FSZHmuj97YUAE,1579
+cat_win/tests/src/web/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cat_win/tests/src/web/test_updatechecker.py,sha256=S3W31JimTUYABuTW8TEgS0QydkZEW64UT947Y6HThz4,4216
+cat_win/tests/src/web/test_urls.py,sha256=cRQWOQdWWLsdhWJFJkn78UMWEWGlYJHWGEGRyMZ7gz0,1703
 cat_win/tests/texts/ansi-base.txt,sha256=0CuJLmkfHxqzMD2B2KdESuC2ac3V2cZ0AUcBePjdusM,156
 cat_win/tests/texts/ansi-neg.txt,sha256=ilg5Sal3yyHpPWAWCVH0YdOwDCcTZ2uBEUmFMCpHorQ,246
 cat_win/tests/texts/ansi-pos.txt,sha256=9TdfRijcTmsHL-r0uwVaX2GKAx2pZukV7pNqgW6vrGs,426
 cat_win/tests/texts/full_test_eval.txt,sha256=9uVYfxbsQhggpN2p0B8V2dHaawCwMveLVr1H2UC4a6w,20
 cat_win/tests/texts/full_test_result_B.txt,sha256=tyeLVATdjB8xhzu6u0c6MXkgCqyad3iHFhhl5IGbh-Y,170
 cat_win/tests/texts/full_test_result_C.txt,sha256=qSlh2v-HEy16xxGUpHBKtqgo0e0m0oPHVyfajOGSFNQ,196
 cat_win/tests/texts/full_test_result_D.txt,sha256=tKnFv7YRL4i7TH_w5-wHCOkduVNgsfY30qQatQz7iwE,141
@@ -53,39 +91,12 @@
 cat_win/tests/texts/test_empty.txt,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cat_win/tests/texts/test_holderEdgeCase_1.txt,sha256=Q_wPnwyLv3e_G6LZyNHzTrwwMQ1JE9DZniWMedCqdNk,19
 cat_win/tests/texts/test_holderEdgeCase_2.txt,sha256=ymXZZIIoOlV7OCZOtILNjK8N8_vM3EcqVbhjDcFS82M,21
 cat_win/tests/texts/test_holderEdgeCase_3.txt,sha256=LBK_BFezVkbLvuk7deYwBTNrSvi1g6Ch-eoTN_OuY5A,28
 cat_win/tests/texts/test_holderEdgeCase_4.txt,sha256=p4hyhdlhpSAgGFo7gm05WfgbOXrlZg70PBumM2ryxMc,10
 cat_win/tests/texts/test_oneline.txt,sha256=n4bQgYhMfWWaL-qgxVrQFaO_TxsrC4Is0V1sFbDwCgg,4
 cat_win/tests/texts/test_peek.txt,sha256=QkXUk1LoS7ZhVCaQRvzTsJBwvTqfVDfu4ukfKTtvQeU,62
-cat_win/util/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cat_win/util/argparser.py,sha256=HdfOad_FoDj5dJvKJIE12Ao-C0JT5wn1uEMlJNfR_zg,13161
-cat_win/util/holder.py,sha256=w-AfykwNK3jlwluN7MpKGyUla642ZMIizcF-lrkN44M,8765
-cat_win/util/helper/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cat_win/util/helper/editorhelper.py,sha256=n_4AwjL9h-JwdTR_W2YFTEm5IZSQzf-hShC6f7lbCho,13795
-cat_win/util/helper/file.py,sha256=SIZJQb0N1rKNSMXjL6CGyy-wVTFtes33GM6LhUL_Des,824
-cat_win/util/helper/stdinhelper.py,sha256=KD6mFIUMsoeFvRGUOnEqEY0JSQiyclTYQLJ362vrGKA,8516
-cat_win/util/helper/tmpfilehelper.py,sha256=t2ZBKJTAnBDHDrU-Y2bt4YbRpHEdpjDkyVVNVZ6o0Ss,703
-cat_win/util/helper/utility.py,sha256=1FEgnPAJL31_zrJsNiwQzg81TmgUDS2ziIRmvv_bQ-U,2002
-cat_win/util/helper/utilityold.py,sha256=EX0wd83KQmZNYqhGA7HOlUr5V9-IaZ6W2zTlbkFmtW8,2172
-cat_win/util/helper/winstreams.py,sha256=jnmgySnvuJ6oEqkYSyei_Y-YfyDRlHeFK69CeANNyEc,1942
-cat_win/util/helper/zipviewer.py,sha256=t6cfbSYqs8dxTQf9xB8PvcI2IO6BwSyzyoWrMdvzWDU,1396
-cat_win/util/service/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cat_win/util/service/cbase64.py,sha256=BtzuclIvE8Bd4mzS58Ei_dOoc6KaT6oiiXlZHtBIgF0,3004
-cat_win/util/service/checksum.py,sha256=ahCkzIFUdqAyeZHAzFCJ__WXpbHa3R4urZfFIKDNot0,2193
-cat_win/util/service/converter.py,sha256=xbZyvX8lAz7ikVGqCRPnW9UUnM2kVE_rIVKW9301mCg,9991
-cat_win/util/service/editor.py,sha256=2p48MQYyoWfA_nkOiRaEZ44RU1gUpg45guQz14JYd-4,38690
-cat_win/util/service/fileattributes.py,sha256=Qwl8zwNQazxHOsJtPrqHPEGIrsVRAhXkHsqAwQC8eYA,5096
-cat_win/util/service/formatter.py,sha256=3_QqdATMKxjPbFuC4nGDZzA2duFToC2LPpjo0mhCYrk,2141
-cat_win/util/service/more.py,sha256=VbI3kWpQ7nrDjRfvyPy75QnrOgYlr8O6rpQ1fNKSfLk,8476
-cat_win/util/service/rawviewer.py,sha256=j343sV4v8_nunPa5Cuj_SabIJQdbCXzuBH6X0L1vOJc,4897
-cat_win/util/service/stringfinder.py,sha256=_NEuwDe5vKLWgEWb_q3UhGUYYxay-bOELdTNwwWqPM0,4421
-cat_win/util/service/strings.py,sha256=lCRVHhDsY_d43My98H4ti7zjE-sl9HtyYGeqRP6f1tI,1179
-cat_win/util/service/summary.py,sha256=N0x4j8L2FuRg6QINq8AIIeVcAKGavXDveaKrG9tUHxo,8158
-cat_win/web/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cat_win/web/updatechecker.py,sha256=Y0l2t1qkIfgv667kYpQFPlwL4aEMwKodflc9v2ltNjI,6832
-cat_win/web/urls.py,sha256=qIW3fXdcTqWkDen-ASCHoKKtDdrQWmK-jdYZMvhsej0,2527
-cat_win-1.7.5.dist-info/entry_points.txt,sha256=kY9wdvnEkIF8Oct5hBPnAIbMCNUOpVKz5dkzyQGcofM,93
-cat_win-1.7.5.dist-info/LICENSE,sha256=NAVv5tZNRy959OCN6_-HDSJxJAU98noU00J6PBDJX14,1090
-cat_win-1.7.5.dist-info/WHEEL,sha256=EZbGkh7Ie4PoZfRQ8I0ZuP9VklN_TvcZ6DSE5Uar4z4,81
-cat_win-1.7.5.dist-info/METADATA,sha256=4XOPW_yjxkM0n6ukaIgZuUhT2b_ap9kUIKMYDCJSzWs,11969
-cat_win-1.7.5.dist-info/RECORD,,
+cat_win-1.7.6.dist-info/entry_points.txt,sha256=kY9wdvnEkIF8Oct5hBPnAIbMCNUOpVKz5dkzyQGcofM,93
+cat_win-1.7.6.dist-info/LICENSE,sha256=NAVv5tZNRy959OCN6_-HDSJxJAU98noU00J6PBDJX14,1090
+cat_win-1.7.6.dist-info/WHEEL,sha256=EZbGkh7Ie4PoZfRQ8I0ZuP9VklN_TvcZ6DSE5Uar4z4,81
+cat_win-1.7.6.dist-info/METADATA,sha256=ib95RNlx0FZm1RyAF7dDNe61byYKBwbtCW_LMnXqyLM,12086
+cat_win-1.7.6.dist-info/RECORD,,
```

